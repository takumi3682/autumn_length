[
  {
    "objectID": "reports/生物季節観測相関.html#データ概要",
    "href": "reports/生物季節観測相関.html#データ概要",
    "title": "生物季節観測データの相互相関解析",
    "section": "データ概要",
    "text": "データ概要\n\n元データ: 仙台 における生物季節観測データ および 月平均気温から算出した季節平均値\n「さくら開花」などは年の初め（1月1日）から数えて何日目（Days of Year） で表現\nspring:3〜5月、summer:6〜8月、autumn:9〜11月、winter:12〜2月　 の平均気温\n下表は表の抜粋\n\n\n\n\n\n\n年\nさくら開花\nすすき開花\nいちょう黄葉\nspring\nautumn\nwinter\n\n\n\n\n1953\n101\nNA\nNA\n9.4\n13.5\n2.7\n\n\n1954\n96\nNA\nNA\n10.0\n14.5\n2.1\n\n\n1955\n101\nNA\nNA\n9.8\n14.0\n1.9\n\n\n1956\n106\nNA\n320\n9.5\n14.4\n1.1\n\n\n1957\n106\nNA\n310\n9.1\n14.2\n2.7\n\n\n1958\n100\n254\n315\n9.4\n13.6\n3.3\n\n\n1959\n94\n253\n304\n10.9\n15.0\n2.3\n\n\n1960\n102\n231\n305\n9.6\n14.8\n1.3\n\n\n1961\n101\n240\n307\n10.7\n15.7\n2.4\n\n\n1962\n104\n246\n309\n9.9\n14.4\n2.0"
  },
  {
    "objectID": "reports/生物季節観測相関.html#生物季節観測時系列仙台",
    "href": "reports/生物季節観測相関.html#生物季節観測時系列仙台",
    "title": "生物季節観測データの相互相関解析",
    "section": "生物季節観測（時系列、仙台）",
    "text": "生物季節観測（時系列、仙台）"
  },
  {
    "objectID": "reports/生物季節観測相関.html#spearman検定",
    "href": "reports/生物季節観測相関.html#spearman検定",
    "title": "生物季節観測データの相互相関解析",
    "section": "Spearman検定",
    "text": "Spearman検定\n\nデータを順位（runk）に変換してから計算する相関検定\n2つの変数が単調な関係にあるかどうかを調べる\n外れ値に強く、正規分布である必要がない\nデータ数 \\(n\\)、各データペアの順位の差を\\(d_{i}\\)とすると、\n\n\\[\n\\rho = 1 - \\frac{6 \\sum d_i^2}{n \\left( n^2 - 1 \\right)}\n\\]\n\nSpearmanによる相関係数を先ほどのデータに適用した結果を示す"
  },
  {
    "objectID": "notebooks/python/体感温度による秋判定-対象月制限.html",
    "href": "notebooks/python/体感温度による秋判定-対象月制限.html",
    "title": "",
    "section": "",
    "text": "# 対象月を制限する\n#　秋入りは9月以降、冬入りは10月以降\n\n\n%load_ext autoreload\n%autoreload 2\n\nfrom meteo_lib import PROJECT  # または: from meteo_lib.paths import PROJECT\n#out_dir  = PROJECT / \"outputs\"\n\nfrom meteo_lib.meteo_lib import getBlock, get_HourlyData, get_10minData\nfrom meteo_lib.my_path_utils import DATA, OUT\n\nimport pandas as pd\nimport math\nimport numpy as np\nfrom datetime import datetime, timedelta, date, time\nfrom metpy.units import units\nfrom metpy.calc import dewpoint_from_relative_humidity\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.rcParams[\"font.family\"] = \"Hiragino Sans\"   # 例：Noto Sans CJK JP でも可\nmpl.rcParams[\"axes.unicode_minus\"] = False    # －が豆腐になるのを回避\n\nimport matplotlib.dates as mdates\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.ticker import FuncFormatter, MultipleLocator\nimport os\nfrom pathlib import Path\nimport calendar\nfrom IPython.display import display \n\n\n# 移動平均：5日　　持続窓：7日　　多数決：5/7　　快適帯：18℃ ≤ AT ≤ 24℃　　\n# 秋入り：24℃以下  秋明け：18℃未満\n\nimport pandas as pd\nimport numpy as np\n\ndef _find_event_by_majority(flag: pd.Series, window: int, majority: int):\n    \"\"\"\n    flag: bool Series（indexはDatetimeIndex、日次で連続が望ましい）\n    window日間のうち majority日以上 True なら成立。\n    成立したら、その成立窓の中で最初にTrueになった日を返す。\n    \"\"\"\n    flag = flag.astype(bool)\n    if len(flag) &lt; window:\n        return None\n\n    roll = flag.astype(int).rolling(window, min_periods=window).sum()\n    hit = roll &gt;= majority\n    if not hit.any():\n        return None\n\n    d_star = hit.idxmax()  # 最初に成立した日（右端日）\n    win = flag.loc[d_star - pd.Timedelta(days=window-1) : d_star]\n    idx = win.index[win.to_numpy()]\n    return idx[0] if len(idx) else None\n\n\ndef find_autumn_period_month_limited_multi(\n    csv_path,\n    cols=(\"AT\", \"AT_daily\", \"temp\", \"temp_daily\"),\n    date_col=\"日時\",\n    ma_days=5,\n    window=7,\n    majority=5,\n    th_hi=24.0,\n    th_lo=18.0,\n    # 探索する月の範囲\n    start_month_hi=7,   # 秋入り探索開始月\n    end_month_hi=12,    # 秋入り探索終了月\n    start_month_lo=8,   # 秋明け探索開始月（秋入り後にさらに絞る）\n    end_month_lo=2,     # 秋明け探索終了月（翌年2月まで許す、など）\n    # 出力形式\n    return_wide=True,\n):\n    \"\"\"\n    4系列など複数列をループで秋入り/秋明けを算出。\n    - MAはright（center=False）\n    - 日次に連続化して窓（7日）が暦通りに効くようにする\n    \"\"\"\n    df0 = pd.read_csv(csv_path, parse_dates=[date_col]).set_index(date_col).sort_index()\n\n    # 日次連続化（欠測があっても窓が「7日」のままになる）\n    full_index = pd.date_range(df0.index.min(), df0.index.max(), freq=\"D\")\n    df0 = df0.reindex(full_index)\n\n    years = sorted(pd.Index(full_index.year).unique())\n    rows = []\n\n    for col in cols:\n        if col not in df0.columns:\n            raise KeyError(f\"column '{col}' not found in CSV\")\n\n        s = df0[col].astype(float)\n        ma = s.rolling(ma_days, min_periods=ma_days).mean()  # 5日移動平均（right）\n        cool = (ma &lt;= th_hi).fillna(False)\n        cold = (ma &lt; th_lo).fillna(False)\n\n        for y in years:\n            # 秋入り探索（年内、月で絞る）\n            start_hi = pd.Timestamp(y, start_month_hi, 1)\n            end_hi   = (pd.Timestamp(y, end_month_hi, 1) + pd.offsets.MonthEnd(0))\n\n            cool_y = cool.loc[start_hi:end_hi]\n            autumn_start = _find_event_by_majority(cool_y, window, majority)\n\n            if autumn_start is None:\n                rows.append({\n                    \"year\": y, \"series\": col,\n                    \"autumn_start\": pd.NaT, \"autumn_end\": pd.NaT, \"length_days\": np.nan\n                })\n                continue\n\n            # 秋明け探索（秋入り以降〜 end_month_lo 末まで。年またぎ対応）\n            # end_month_lo が start_month_lo より小さい場合は翌年まで\n            y_end = y + (1 if end_month_lo &lt; start_month_lo else 0)\n            span_end = (pd.Timestamp(y_end, end_month_lo, 1) + pd.offsets.MonthEnd(0))\n\n            cold_span = cold.loc[autumn_start:span_end]\n\n            # 月の絞り（年またぎ考慮）\n            if end_month_lo &gt;= start_month_lo:\n                mask_lo = (cold_span.index.month &gt;= start_month_lo) & (cold_span.index.month &lt;= end_month_lo)\n            else:\n                mask_lo = (cold_span.index.month &gt;= start_month_lo) | (cold_span.index.month &lt;= end_month_lo)\n\n            cold_span = cold_span[mask_lo]\n            autumn_end = _find_event_by_majority(cold_span, window, majority)\n\n            length = (autumn_end - autumn_start).days + 1 if pd.notna(autumn_end) else np.nan\n\n            rows.append({\n                \"year\": y, \"series\": col,\n                \"autumn_start\": autumn_start, \"autumn_end\": autumn_end, \"length_days\": length\n            })\n\n    out_long = pd.DataFrame(rows).sort_values([\"series\", \"year\"]).reset_index(drop=True)\n\n    if not return_wide:\n        return out_long\n\n    out_wide = (out_long.pivot(index=\"year\", columns=\"series\",\n                              values=[\"autumn_start\", \"autumn_end\", \"length_days\"])\n                        .sort_index())\n    return out_long, out_wide\n\n\ncsv_path = DATA / \"AT_仙台_1970-2024.csv\"\n\nout_long, out_wide = find_autumn_period_month_limited_multi(\n    csv_path,\n    cols=(\"AT\", \"AT_daily\", \"temp\", \"temp_daily\"),\n    ma_days=5, window=7, majority=5,\n    start_month_hi=9, end_month_hi=12,  # 秋入り探索\n    start_month_lo=10, end_month_lo=2,   # 秋明け探索（翌年2月まで）\n)\n#display(out_long.head)\ndisplay(out_wide.head())\n\nout_path = OUT /  \"体感温度_仙台_月縛り.csv\"\nout_wide.to_csv(out_path)\n\n\n\n\n\n\n\n\nautumn_start\nautumn_end\nlength_days\n\n\nseries\nAT\nAT_daily\ntemp\ntemp_daily\nAT\nAT_daily\ntemp\ntemp_daily\nAT\nAT_daily\ntemp\ntemp_daily\n\n\nyear\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1970\n1970-09-07\n1970-09-15\n1970-09-01\n1970-09-07\n1970-10-01\n1970-10-01\n1970-10-01\n1970-10-01\n25\n17\n31\n25\n\n\n1971\n1971-09-01\n1971-09-01\n1971-09-01\n1971-09-01\n1971-10-01\n1971-10-01\n1971-10-01\n1971-10-01\n31\n31\n31\n31\n\n\n1972\n1972-09-02\n1972-09-11\n1972-09-01\n1972-09-01\n1972-10-01\n1972-10-01\n1972-10-01\n1972-10-13\n30\n21\n31\n43\n\n\n1973\n1973-09-06\n1973-09-07\n1973-09-05\n1973-09-07\n1973-10-05\n1973-10-06\n1973-10-05\n1973-10-06\n30\n30\n31\n30\n\n\n1974\n1974-09-08\n1974-09-09\n1974-09-01\n1974-09-01\n1974-10-02\n1974-10-05\n1974-10-02\n1974-10-08\n25\n27\n32\n38\n\n\n\n\n\n\n\n\ndf_A = out_wide.xs(\"autumn_start\", level=0, axis=1)\ndf_A.head()\n\n\n\n\n\n\n\nseries\nAT\nAT_daily\ntemp\ntemp_daily\n\n\nyear\n\n\n\n\n\n\n\n\n1970\n1970-09-07\n1970-09-15\n1970-09-01\n1970-09-07\n\n\n1971\n1971-09-01\n1971-09-01\n1971-09-01\n1971-09-01\n\n\n1972\n1972-09-02\n1972-09-11\n1972-09-01\n1972-09-01\n\n\n1973\n1973-09-06\n1973-09-07\n1973-09-05\n1973-09-07\n\n\n1974\n1974-09-08\n1974-09-09\n1974-09-01\n1974-09-01\n\n\n\n\n\n\n\n\n#fig, ax1 = plt.subplots(figsize=(10, 5))\nfor s in out_wide.columns.levels[1]:\n    df_s = out_wide.xs(s, level=\"series\", axis=1)\n    fig, ax = plt.subplots()\n    ax.plot(df_s.index, df_s[\"length_days\"], linestyle=\"\", marker=\"o\")\n    ax.set_title(f\"Series {s}\")\n    ax.set_ylabel(\"Autumn length (days)\")\n    ax.set_xlabel(\"Year\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndf = out_wide.xs(\"autumn_start\", level=0, axis=1)\n#index : year (1970, 1971, ...)\n#columns : series (AT, AT_daily, temp, temp_daily)\n#values : datetime64[ns]\n\ndf_doy = df.apply(lambda s: s.dt.dayofyear)    # datetime=&gt;DOY(day of year)\nfig, ax = plt.subplots(figsize=(7, 4))\n\nfor col in df_doy.columns:\n    ax.plot(df_doy.index, df_doy[col], marker=\"o\", label=col)\n\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Date\")\nax.set_title(\"Autumn start (month-day comparison)\")\nax.legend()\n\nimport matplotlib.dates as mdates\nfrom datetime import datetime\n\ndef doy_to_mmdd(doy):\n    return datetime(2001, 1, 1) + pd.to_timedelta(doy - 1, unit=\"D\")\n\nax.yaxis.set_major_formatter(\n    lambda x, pos: doy_to_mmdd(int(x)).strftime(\"%m/%d\")\n)\n\nplt.show()"
  },
  {
    "objectID": "notebooks/python/体感温度.html",
    "href": "notebooks/python/体感温度.html",
    "title": "",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n\nfrom meteo_lib import PROJECT  # または: from meteo_lib.paths import PROJECT\n#out_dir  = PROJECT / \"outputs\"\n\nfrom meteo_lib.meteo_lib import getBlock, get_HourlyData, get_10minData\nfrom meteo_lib.my_path_utils import DATA, OUT\n\nimport pandas as pd\nimport math\nimport numpy as np\nfrom datetime import datetime, timedelta, date, time\nfrom metpy.units import units\nfrom metpy.calc import dewpoint_from_relative_humidity\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.rcParams[\"font.family\"] = \"Hiragino Sans\"   # 例：Noto Sans CJK JP でも可\nmpl.rcParams[\"axes.unicode_minus\"] = False    # －が豆腐になるのを回避\n\nimport matplotlib.dates as mdates\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.ticker import FuncFormatter, MultipleLocator\nimport os\nfrom pathlib import Path\nimport calendar\nfrom IPython.display import display \n\n\n# ---- BOM式 Apparent Temperature ----\ndef apparent_temperature(T, V, e=None, RH=None):\n    if e is None:\n        if RH is None:\n            return pd.Series(np.nan, index=T.index)\n        e = 6.105 * np.exp((17.27*T)/(237.7+T)) * (RH/100.0)  # hPa\n    return T + 0.33*e - 0.70*V - 4.00\n\n\n# Apparent Temperature の中央値を求める t_min〜t_max\ndef get_AT_median(s: pd.Series, t_min: pd.Timestamp, t_max: pd.Timestamp):\n    s = pd.to_numeric(s, errors='coerce')\n    idx = pd.to_datetime(s.index, errors='coerce')\n    s = s.loc[idx.notna()]\n    m = (s.index &gt;= t_min) & (s.index &lt;= t_max)\n#    print(s.loc[m])\n    return float(s.loc[m].median(skipna=True)) if m.any() else None\n\n\ndef DataConversion(df: pd.DataFrame, add_column: bool = False) -&gt; pd.DataFrame:\n    df = df.copy()\n\n    # 1) DatetimeIndex 化\n    if '日時' in df.columns:\n        df['日時'] = pd.to_datetime(df['日時'], errors='coerce')\n        df = df.set_index('日時').sort_index()\n    else:\n        df.index = pd.to_datetime(df.index, errors='coerce')\n        df = df.sort_index()\n    df = df.loc[df.index.notna()]\n\n    # 必須列チェック\n    if '気温' not in df.columns:\n        # 方針：空を返す（落としたいなら raise でもOK）\n        if add_column:\n            return df.assign(AT=np.nan, at=np.nan, temp=np.nan, at_daily=np.nan, temp_daily=np.nan)\n        return pd.DataFrame(columns=['at','temp','at_daily','temp_daily'])\n\n    # 2) 数値化\n    for c in ['気温', '風速', '蒸気圧']:\n        if c in df.columns:\n            df[c] = pd.to_numeric(df[c], errors='coerce')\n\n    # 3) 体感温度\n    df['AT'] = apparent_temperature(df['気温'], df.get('風速'), df.get('蒸気圧'))\n\n    # ★日境界合わせ：-1時間シフト\n    df_shift = df.copy()\n    df_shift.index = df_shift.index - pd.Timedelta(hours=1)\n    # JMAデータの1日が1：00〜翌日の0：00となっているため、このままだとDataConversion()が\n    # 1日分の毎時データ」から resample('D') をしているのに、その“1日分”の中に翌日の 00:00が\n    # 混ざってしまう。\n    # これを回避するため-1時間シフトしたdf_shitを作ってresampleする。\n\n    # 4) 全日 日中央値\n    at_all  = df_shift['AT'].resample('D').median()\n    tp_all  = df_shift['気温'].resample('D').median()\n\n    # 5) 日中 日中央値（06-18）\n    df_day = df.between_time(time(6,0), time(18,0), inclusive=\"both\")\n    at_day = df_day['AT'].resample('D').median()\n    tp_day = df_day['気温'].resample('D').median()\n\n    daily_df = pd.concat(\n        [at_all.rename('AT'),\n         tp_all.rename('temp'),\n         at_day.rename('AT_daily'),\n         tp_day.rename('temp_daily')],\n        axis=1\n    )\n\n    if add_column:\n        key = df.index.normalize()\n        df['AT']         = key.map(at_all)\n        df['temp']       = key.map(tp_all)\n        df['AT_daily']   = key.map(at_day)\n        df['temp_daily'] = key.map(tp_day)\n        return df\n\n    return daily_df\n\n\ndef get_Webdata(prec, block, y_start, y_end, m_start, m_end):\n    frames = []\n    for y in range(y_start, y_end+1):\n        print('now: ', y)\n        for m in range(m_start, m_end+1):\n            days = calendar.monthrange(y, m)[1]\n            for d in range(1, days+1):\n                df = get_HourlyData(prec, block, y, m, d)\n                AT_daily = DataConversion(df, add_column=False)\n                frames.append(AT_daily)\n#                print(y, m, d, AT_daily)\n    AT = pd.concat(frames, axis=0, ignore_index=False)\n    display(AT)\n\n    AT.sort_index(inplace=True)\n    AT.to_csv(outdata)\n\n\npref, station = '山形県', '山形'\ninfo = getBlock(pref, station)\n#print(info)\nprec, block, st_name = info['prec'], info['block'], info[\"Name_2\"]\n\ny_start, y_end = 1970, 2024\nm_start, m_end = 1, 12\n\noutdata = DATA / f\"AT_{station}_{y_start}-{y_end}.csv\"\n\nif outdata.exists():\n    print(\"from Local\")\n    AT = pd.read_csv(outdata)\nelse:\n    print(\"from Web\")\n    AT = get_Webdata(prec, block, y_start, y_end, m_start, m_end)\ndisplay(AT)\n\nfrom Web\nnow:  1970\nnow:  1971\nnow:  1972\nnow:  1973\nnow:  1974\nnow:  1975\nnow:  1976\nnow:  1977\nnow:  1978\nnow:  1979\nnow:  1980\nnow:  1981\nnow:  1982\nnow:  1983\nnow:  1984\nnow:  1985\nnow:  1986\nnow:  1987\nnow:  1988\nnow:  1989\nnow:  1990\nnow:  1991\nnow:  1992\nnow:  1993\nnow:  1994\nnow:  1995\nnow:  1996\nnow:  1997\nnow:  1998\nnow:  1999\nnow:  2000\nnow:  2001\nnow:  2002\nnow:  2003\nnow:  2004\nnow:  2005\nnow:  2006\nnow:  2007\nnow:  2008\nnow:  2009\nnow:  2010\nnow:  2011\nnow:  2012\nnow:  2013\nnow:  2014\nnow:  2015\nnow:  2016\nnow:  2017\nnow:  2018\nnow:  2019\nnow:  2020\nnow:  2021\nnow:  2022\nnow:  2023\nnow:  2024\n\n\n\n\n\n\n\n\n\nAT\ntemp\nAT_daily\ntemp_daily\n\n\n日時\n\n\n\n\n\n\n\n\n1970-01-01\n-6.8460\n-2.55\n-6.2705\n-2.6\n\n\n1970-01-02\n-4.9175\n-0.95\n-4.2230\n-0.8\n\n\n1970-01-03\n-6.6690\n-3.80\n-5.5590\n-2.6\n\n\n1970-01-04\n-8.0335\n-4.40\n-6.8695\n-3.3\n\n\n1970-01-05\n-8.2150\n-4.40\n-8.2150\n-2.6\n\n\n...\n...\n...\n...\n...\n\n\n2024-12-27\n-3.5500\n0.00\n-3.6010\n0.1\n\n\n2024-12-28\n-4.4155\n-0.80\n-2.7100\n0.9\n\n\n2024-12-29\n-5.0650\n-1.75\n-4.0870\n-1.0\n\n\n2024-12-30\n-1.3360\n1.40\n-0.0840\n2.9\n\n\n2024-12-31\n-1.1800\n1.55\n-0.1590\n3.1\n\n\n\n\n20089 rows × 4 columns\n\n\n\nNone\n\n\n\nyear = 1970\nmonth_min, month_max = 1, 2\nREF_YEAR = 2001\ndays = calendar.monthrange(year, month_max)[1]\nx_min, x_max =  pd.to_datetime(f\"{year}-{month_min}-01\"), pd.to_datetime(f\"{year}-{month_max}-{days}\")\n\ndef to_refdate(s: pd.Series) -&gt; pd.Series:\n    # 年を消して「月日だけ」を基準年に載せ替え（NaTはNaTのまま）\n    return pd.to_datetime(\n        np.where(s.notna(), s.dt.strftime(f\"{REF_YEAR}\" + \"-%m-%d\"), pd.NaT),\n        errors=\"coerce\"\n    )\ndate_ref = pd.to_datetime(AT['日時'])\nx = to_refdate(date_ref)\n\nfig, ax1 = plt.subplots(figsize=(10, 5))\nmask = date_ref.dt.year==year\nax1.plot(date_ref[mask], AT[mask]['temp'], \n         linestyle='-', color=\"red\", label=f'気温[{year}]')\nax1.plot(date_ref[mask], AT[mask]['at'], \n         linestyle='-', color=\"blue\", label=f'体感温度[{year}]')\nax1.plot(date_ref[mask], AT[mask]['temp_daily'], \n         linestyle='--', color=\"red\", label=f'気温（昼間）[{year}]')\nax1.plot(date_ref[mask], AT[mask]['at_daily'], \n         linestyle='--', color=\"blue\", label=f'体感温度（昼間）[{year}]')\nax1.set_xlim(x_min, x_max)\nax1.tick_params(axis='x', labelrotation=45)\nax1.set_ylim(-10,40)\nax1.grid()\nax1.legend()\nplt.title(f'気温・体感温度 {station} {year}')\nplt.show()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 13\n      7 def to_refdate(s: pd.Series) -&gt; pd.Series:\n      8     # 年を消して「月日だけ」を基準年に載せ替え（NaTはNaTのまま）\n      9     return pd.to_datetime(\n     10         np.where(s.notna(), s.dt.strftime(f\"{REF_YEAR}\" + \"-%m-%d\"), pd.NaT),\n     11         errors=\"coerce\"\n     12     )\n---&gt; 13 date_ref = pd.to_datetime(AT['日時'])\n     14 x = to_refdate(date_ref)\n     16 fig, ax1 = plt.subplots(figsize=(10, 5))\n\nNameError: name 'AT' is not defined\n\n\n\n\nyear = 1993\nx_min, x_max = pd.to_datetime(f\"{year}-01-01\"), pd.to_datetime(f\"{year}-12-31\")\ny_min, y_max = -15, 10\nfig, ax = plt.subplots(1,1,figsize=(10,5))\n#ax.plot(AT.index, AT['at_daily'], linestyle='none', marker='o')\n#ax.plot(AT.index, AT['temp_daily'], linestyle='none', marker='^')\n#ax.plot(AT.index, AT['at_daily'], linestyle='-', label='AT')\n#ax.plot(AT.index, AT['temp_daily'], linestyle='-', label='Temp')\n\nax.bar(AT.index, (AT['at_daily']-AT['temp_daily']), linestyle='-', label='f{year}')\nax.set_xlim(x_min, x_max)\nax.set_ylim(y_min, y_max)\nplt.title(f'「体感温度ー気温」 {station} {year}')\n#ax.legend()\nplt.savefig(OUT / f'体感温度ー気温{station}_{year}.png')\nplt.show()\n\n\nimport seaborn as sns\n\ndef make_year_calendar_heatmap(\n    df: pd.DataFrame,\n    date_col: str,\n    value_col: str,\n    drop_feb29: bool = True,\n    md_range: tuple[str, str] | None=None,\n    cmap: str = \"coolwarm\",\n    vmin: float | None=None,\n    vmax: float | None=None,\n    fig_size: tuple[float, float] = (12, 6),\n):\n    data = df[[date_col, value_col]].dropna(subset=[date_col]).copy()\n    data[date_col] = pd.to_datetime(data[date_col], errors=\"coerce\")\n    data = data.loc[data[date_col].notna()]\n\n    data[\"year\"] = data[date_col].dt.year\n    data[\"month\"] = data[date_col].dt.month\n    data[\"day\"] = data[date_col].dt.day\n\n    if drop_feb29:\n        data = data[~((data[\"month\"] == 2) & (data[\"day\"] == 29))]\n\n    REF_YEAR = 2001\n    data[\"md_ref\"] = pd.to_datetime(\n        data[date_col].dt.strftime(f\"{REF_YEAR}\" + \"-%m-%d\"), errors=\"coerce\"\n    )\n\n    # 月日範囲で抽出（同年内の範囲を想定）\n    if md_range is not None:\n        md_start = pd.to_datetime(f\"{REF_YEAR}-{md_range[0]}\")\n        md_end   = pd.to_datetime(f\"{REF_YEAR}-{md_range[1]}\")\n        data = data[(data[\"md_ref\"] &gt;= md_start) & (data[\"md_ref\"] &lt;= md_end)]\n\n    # 透視図：index=年, columns=md_ref（昇順）\n    table = (\n        data.pivot_table(index=\"year\", columns=\"md_ref\", values=value_col, aggfunc=\"mean\")\n        .sort_index(axis=1)\n        .sort_index(axis=0)\n    )\n\n    # プロット\n    plt.figure(figsize=fig_size)\n    # NaN色を調整（欠測が多い場合に灰色などに）\n\n    vmin, vmax = -10, 40\n\n    cmap_obj = mpl.colormaps.get_cmap(cmap).copy()\n    cmap_obj.set_bad(\"lightgray\")\n    mask = table.lt(vmin) | table.gt(vmax)\n\n    ax = sns.heatmap(\n        table,\n#        mask=mask,\n#        cmap=cmap_obj,\n        cmap=\"RdBu_r\",\n#        center=0,\n        vmin=vmin, vmax=vmax,  # 年比較では固定推奨\n        cbar_kws={\"label\": value_col},\n    )\n\n    # x軸：月初に目盛りを置く\n    cols = table.columns\n    # 列インデックスを必ず DatetimeIndex に揃える\n    if not isinstance(cols, pd.DatetimeIndex):\n        cols = pd.to_datetime(cols)\n        # DataFrame本体の columns も揃えておくと後続も安全\n        table.columns = cols\n\n    # 月初（MS=Month Start）を作成\n    REF_YEAR = 2001\n    months = pd.date_range(f\"{REF_YEAR}-01-01\", f\"{REF_YEAR}-12-01\", freq=\"MS\")\n    #months = pd.to_datetime([f\"{REF_YEAR}-{m:02d}-01\" for m in range(1,13)])\n\n    # DatetimeIndex.same-type で searchsorted（NumPyではなくPandasのIndexメソッド）\n    month_locs = cols.searchsorted(months)\n    # 表示範囲外を除外\n    month_locs = month_locs[month_locs &lt; len(cols)]\n\n    ax.set_xticks(month_locs)\n    # ラベル数は month_locs の長さに合わせる\n    tick_labels = [m.strftime(\"%-m/%-d\") for m in months[:len(month_locs)]]\n    ax.set_xticklabels(tick_labels, rotation=0)\n\n    ax.set_xlabel(\"Month / Day\")\n    ax.set_ylabel(\"Year\")\n    ax.set_title(f\"Calendar Heatmap: {value_col}\")\n\n    plt.tight_layout()\n    plt.show()\n\n\n# -------------------------\n# 使い方サンプル\n# -------------------------\n# 例1) 年・月・日から date を作る場合（JMA風テーブル想定）\n# df_raw に列 ['年','月','日','日平均気温'] があるとする\n# df_raw = ...\n# df_raw['date'] = pd.to_datetime(dict(year=df_raw['年'], month=df_raw['月'], day=df_raw['日']))\n# make_year_calendar_heatmap(df_raw, date_col='date', value_col='日平均気温',\n#                            drop_feb29=True, md_range=(\"06-01\",\"09-30\"),\n#                            cmap=\"coolwarm\", vmin=10, vmax=30, fig_size=(12,6))\n\n# 例2) すでに 'date' と 'value' がある場合\n#AT[\"日時\"] = AT.index\nAT['delta'] = AT['at_daily'] - AT['temp_daily']\nprint(AT)\n\n\"\"\"\nmake_year_calendar_heatmap(AT, date_col='日時', value_col='delta',\n                           drop_feb29=True, md_range=(\"06-01\",\"10-31\"),\n                           cmap=\"mako\", vmin=-5, vmax=5)\n\"\"\"\nmake_year_calendar_heatmap(AT, date_col='日時', value_col='at_daily',\n                           drop_feb29=True, md_range=(\"01-01\",\"12-31\"),\n                           cmap=\"mako\", vmin=-5, vmax=5)\n\n\ndef DataConversion(df: pd.DataFrame, add_column: bool = False) -&gt; pd.DataFrame:\n    # 1) 日時→DatetimeIndex\n    if '日時' in df.columns:\n        df['日時'] = pd.to_datetime(df['日時'], errors='coerce')\n        df = df.set_index('日時').sort_index()\n    else:\n        df.index = pd.to_datetime(df.index, errors='coerce')\n    df = df.loc[df.index.notna()]\n\n    # 2) 数値化\n    for c in ['気温', '風速', '蒸気圧']:\n        if c in df.columns:\n            df[c] = pd.to_numeric(df[c], errors='coerce')\n\n    # 3) 体感温度\n    df['AT'] = apparent_temperature(df.get('気温'), df.get('風速'), df.get('蒸気圧'))\n\n    # 4) 各日 全日の日単位中央値\n    at_daily_alltime = df['AT'].resample('D').median()     # 日ごと中央値（Series）\n    temp_daily_alltime = df['気温'].resample('D').median()     # Series\n\n    # 5) 各日 t_min〜t_max に絞って日単位中央値\n    t_min = 6\n    t_max = 18\n    df_daytime = df.between_time(time(t_min, 0), time(t_max, 0), iclusive='both')       # 全日付対象で日中のみ抽出\n    at_daily_daytime = df_daytime['AT'].resample('D').median()     # 日ごと中央値（Series）\n    temp_daily_daytime = df_daytime['気温'].resample('D').median()     # Series\n\n    # ← ここで4列DataFrame化（列名を at / temp / at_daily / temp_daily に統一）\n    daily_df = pd.concat(\n        [at_daily_alltime.rename('at'),\n         temp_daily_alltime.rename('temp'),\n         at_daily_daytime.rename('at_daily'),\n         temp_daily_daytime.rename('temp_daily')],\n        axis=1\n    )\n    \n    if add_column:\n        # 元の毎時DFの各行に「その日のAT中央値」を付ける\n        df['at'] = df.index.normalize().map(at)\n        df['temp'] = df.index.normalize().map(temp)\n        df['at_daily'] = df.index.normalize().map(at_daily)\n        df['temp_daily'] = df.index.normalize().map(temp_daily)\n        return df  # 毎時データ＋列としてのAT中央値\n    else:\n        return daily_df  # 「1ヶ月分のAT日中央値」だけを返す\n\n\n補足（実務のコツ）\n色域は固定（vmin/vmax）：年間比較の“色の意味”がぶれません（例：気温なら vmin=10, vmax=30 など）。\n\nうるう日の扱い：年比較を揃えるなら drop_feb29=True が無難。どうしても使いたい場合は 2/28 と 3/1 に分配・補間などの前処理を検討。\n\n期間抽出：md_range=(\"06-01\",\"09-30\") で夏期などに絞れます。\n\n欠測の色：cmap.set_bad(\"lightgray\") で一目で分かるように。\n\n列の粒度：日次前提。10分/1時間データなら pcolormesh（座標を渡す）を推奨。\n\n列名が決まっていれば、そのまま差し替え済み版（仙台のJMA日平均気温など）も作れます。サンプルの列名を教えてください。"
  },
  {
    "objectID": "notebooks/python/生物季節観測r3.html",
    "href": "notebooks/python/生物季節観測r3.html",
    "title": "",
    "section": "",
    "text": "生物気象観測 多種データを横持ちで保存\n\n%load_ext autoreload\n%autoreload 2\n\nimport sys\nfrom pathlib import Path\n\ndef add_project_root(marker=\"project_paths.py\") -&gt; Path:\n    p = Path.cwd().resolve()\n    for d in [p, *p.parents]:\n        if (d / marker).exists():\n            sys.path.insert(0, str(d))\n            return d\n    raise FileNotFoundError(f\"Could not find {marker} from cwd={p}\")\n\nPROJECT_ROOT = add_project_root()\nprint(\"Project root:\", PROJECT_ROOT)\n\nfrom project_paths import ROOT as PROJECT, JMA_DATA, OUT, FIG, TAB, REP, CFG\nfrom project_paths import OUT\nfrom meteo_lib.core import getBlock, get_HourlyData, get_10minData\nfrom meteo_lib.paths import JMA_DATA, JMA_GPV_DATA, ERA5_DATA, CACHE_DIR\n\nprint(\"Data root:\",JMA_DATA)\n\nProject root: /Users/takumi/Projects/meteo-analysis/JMA\nData root: /Users/takumi/Projects/MetData/JMA\n\n\n\nimport numpy as np\nimport pandas as pd\nimport math\nfrom datetime import datetime, timedelta, date, time\nimport calendar\nimport os\nfrom pathlib import Path\n\n\ndef datetime_value(x, column_value, base_year=2000):\n\n    if pd.isna(x):\n        return pd.NaT\n\n    x = int(x)\n\n    # yyyymmdd 型\n    if x &gt;= 10000000:\n        s = f\"{v:08d}\"\n        mm = int(s[4:6])\n        dd = int(s[6:8])\n    # mmdd 型\n    else:\n        mm = x // 100\n        dd = x % 100\n\n    # 月日だけを固定年に乗せる\n    return pd.Timestamp(base_year, mm, dd)\n\n\n# 生物季節観測のcsvファイルを読み込む\ndef read_data(fn):\n    cs1 = ['rm', '番号']\n    cs2 = ['平年値', '最早値', '最晩値', '最早年', '最晩年']\n    end_year = 2024\n\n#    print(fn)\n    title_row = pd.read_csv(fn, encoding='shift-jis', nrows=1, header=None).iloc[0,1]\n    df = pd.read_csv(fn, header=1, encoding='shift-JIS',\n                 usecols=lambda column: all(substring not in column for substring in cs1),\n                 index_col='地点名')\n\n    df = df.drop(columns=cs2)\n    df = df.drop(df.columns[df.columns&gt;str(end_year)], axis=1)\n    df.index = df.index.str.strip()  # indexから空白文字を削除\n    df = df.where(df&gt;=100, other=np.nan)\n#    display(df)\n\n    for col in df.columns:\n        df[col] = df[col].apply(datetime_value, args=(col,))\n\n    df = df.transpose()  # 行と列を入れ替える\n    df.index.name = '年'\n\n    return df, title_row\n\n\nfp = JMA_DATA / 'raw/生物季節観測'\nstation = \"仙台\"\n\nsubs = {'うめ開花':1, 'さくら開花':4, 'さくら満開':5, 'あじさい開花':9, 'すすき開花':11,\n        'いちょう黄葉':13, 'いちょう落葉':14,'かえで紅葉':15,'かえで落葉':16}\n\nseries_list = []\n\nfor sub_name in subs.keys():\n    sub_no = str(subs[sub_name]).zfill(3)\n    fn = fp / f\"{sub_no}{sub_name}.csv\"\n#    print(\"file name:\", fn)\n\n    df_part, title_row = read_data(fn)\n\n    s = df_part[station].copy()   # ← station列だけ取り出す（Series）\n    s.name = sub_name              # ← 列名をsub名にする\n    series_list.append(s)\n\n# 横に連結（列方向）\ndf = pd.concat(series_list, axis=1)\ndf_md = df.copy()\nprint(df_md)\n\n# 2/29はNaN、それ以外は「非うるう年基準」のDOYにする\ndef md_to_doy_A(ts):\n    if pd.isna(ts):\n        return np.nan\n    if ts.month == 2 and ts.day == 29:\n        return np.nan\n    return pd.Timestamp(2001, ts.month, ts.day).dayofyear\n\ndf_doy = df_md.map(md_to_doy_A)\ndf_doy_int = df_doy.round().astype(\"Int64\")\nout_fn = OUT / f\"生物季節観測_{station}_DOY.csv\"\ndf_doy_int.to_csv(out_fn)\n\nprint(df_doy)\n\n           うめ開花      さくら開花      さくら満開     あじさい開花      すすき開花     いちょう黄葉  \\\n年                                                                        \n1953 2000-03-14 2000-04-11 2000-04-17        NaT        NaT        NaT   \n1954 2000-03-03 2000-04-06 2000-04-12        NaT        NaT        NaT   \n1955 2000-03-10 2000-04-11 2000-04-16        NaT        NaT        NaT   \n1956 2000-03-14 2000-04-16 2000-04-19 2000-06-05        NaT 2000-11-16   \n1957 2000-04-07 2000-04-16 2000-04-21 2000-06-27        NaT 2000-11-06   \n...         ...        ...        ...        ...        ...        ...   \n2020 2000-03-01 2000-03-28 2000-04-03 2000-06-24 2000-07-27 2000-12-01   \n2021 2000-03-10 2000-03-28 2000-03-31 2000-06-21 2000-07-18 2000-11-30   \n2022 2000-03-15 2000-04-08 2000-04-11 2000-06-27 2000-08-22 2000-11-28   \n2023 2000-03-04 2000-03-26 2000-03-31 2000-06-17 2000-08-14 2000-12-05   \n2024 2000-02-19 2000-04-02 2000-04-09 2000-06-16 2000-08-05 2000-11-28   \n\n         いちょう落葉      かえで紅葉      かえで落葉  \n年                                      \n1953        NaT        NaT        NaT  \n1954        NaT        NaT        NaT  \n1955        NaT        NaT        NaT  \n1956        NaT 2000-10-25        NaT  \n1957 2000-11-25 2000-10-28 2000-11-10  \n...         ...        ...        ...  \n2020 2000-12-16 2000-11-23 2000-11-28  \n2021 2000-12-13 2000-11-24 2000-12-01  \n2022 2000-12-09 2000-11-24 2000-11-29  \n2023 2000-12-14 2000-11-24 2000-12-08  \n2024 2000-12-12 2000-11-22 2000-12-05  \n\n[72 rows x 9 columns]\n      うめ開花  さくら開花  さくら満開  あじさい開花  すすき開花  いちょう黄葉  いちょう落葉  かえで紅葉  かえで落葉\n年                                                                    \n1953  73.0    101    107     NaN    NaN     NaN     NaN    NaN    NaN\n1954  62.0     96    102     NaN    NaN     NaN     NaN    NaN    NaN\n1955  69.0    101    106     NaN    NaN     NaN     NaN    NaN    NaN\n1956  73.0    106    109   156.0    NaN   320.0     NaN  298.0    NaN\n1957  97.0    106    111   178.0    NaN   310.0   329.0  301.0  314.0\n...    ...    ...    ...     ...    ...     ...     ...    ...    ...\n2020  60.0     87     93   175.0  208.0   335.0   350.0  327.0  332.0\n2021  69.0     87     90   172.0  199.0   334.0   347.0  328.0  335.0\n2022  74.0     98    101   178.0  234.0   332.0   343.0  328.0  333.0\n2023  63.0     85     90   168.0  226.0   339.0   348.0  328.0  342.0\n2024  50.0     92     99   167.0  217.0   332.0   346.0  326.0  339.0\n\n[72 rows x 9 columns]\n\n\n\nimport requests\nfrom bs4 import BeautifulSoup\nimport lxml\n\nurl = \"https://www.data.jma.go.jp/stats/etrn/view/monthly_s3.php?prec_no=34&block_no=47590&year=2023&month=1&day=&view=\"\n\ntables = pd.read_html(url)   # ページ内の表を全部DataFrameで取得\n#print(tables)\nlen(tables), [t.shape for t in tables]\nfor i, t in enumerate(tables):\n    print(i, t.columns)\ndf_doy2 = df_doy.copy()\ndf_doy2.index = df_doy2.index.astype(int)   # 文字列→整数\n\ndf_temp = tables[0]\ndf_temp = df_temp.set_index('年')\nprint(df_temp)\nprint(df_doy)\n\ndf = pd.merge(df_doy2, df_temp, left_index=True, right_index=True, how=\"inner\")\n\nprint(df)\nout_fn_df = OUT / f\"生物季節観測_{station}_DOY_Temp.csv\"\ndf.to_csv(out_fn_df)\n\n0 Index(['年', '1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月',\n       '12月', '年の値'],\n      dtype='object')\n1 Index([0, 1, 2, 3], dtype='int64')\n         1月   2月   3月    4月    5月    6月    7月    8月    9月   10月   11月  12月  \\\n年                                                                            \n1926    NaN  NaN  NaN   NaN   NaN   NaN   NaN   NaN   NaN  11.8   6.8  1.7   \n1927   -0.6 -1.5  2.5   9.0  13.6  17.6  23.4  24.2  18.5  13.9   8.3  2.1   \n1928    0.4  0.1  2.9   8.8  13.7  16.9  21.1  22.4  21.6  14.2   8.8  1.4   \n1929   -1.3 -0.7  2.9   8.7  12.9  16.7  23.3  24.9  18.7  14.3   8.2  5.0   \n1930   -0.6  1.9  5.6   9.9  14.4  18.4  22.4  24.5  19.2  13.9   6.8  2.3   \n...     ...  ...  ...   ...   ...   ...   ...   ...   ...   ...   ...  ...   \n2022    1.7  1.9  6.4  11.8  16.5  20.2  24.9  25.1  22.2  15.5  11.9  4.2   \n2023    2.1  3.0  9.3  13.3  16.6  21.6  26.6  28.6  25.1  16.7  11.4  5.7   \n2024    4.2  4.7  6.0  14.8  17.8  21.5  26.1  27.4  23.5  18.0  10.9  4.3   \n2025    3.2  2.7  7.6  12.0  16.2  22.8  27.2  27.5  23.8  16.2  10.5  5.7   \n2026  2.3 ]  NaN  NaN   NaN   NaN   NaN   NaN   NaN   NaN   NaN   NaN  NaN   \n\n        年の値  \n年            \n1926  6.8 ]  \n1927   10.9  \n1928   11.0  \n1929   11.1  \n1930   11.6  \n...     ...  \n2022   13.5  \n2023   15.0  \n2024   14.9  \n2025   14.6  \n2026      ×  \n\n[101 rows x 13 columns]\n      うめ開花  さくら開花  さくら満開  あじさい開花  すすき開花  いちょう黄葉  いちょう落葉  かえで紅葉  かえで落葉\n年                                                                    \n1953  73.0    101    107     NaN    NaN     NaN     NaN    NaN    NaN\n1954  62.0     96    102     NaN    NaN     NaN     NaN    NaN    NaN\n1955  69.0    101    106     NaN    NaN     NaN     NaN    NaN    NaN\n1956  73.0    106    109   156.0    NaN   320.0     NaN  298.0    NaN\n1957  97.0    106    111   178.0    NaN   310.0   329.0  301.0  314.0\n...    ...    ...    ...     ...    ...     ...     ...    ...    ...\n2020  60.0     87     93   175.0  208.0   335.0   350.0  327.0  332.0\n2021  69.0     87     90   172.0  199.0   334.0   347.0  328.0  335.0\n2022  74.0     98    101   178.0  234.0   332.0   343.0  328.0  333.0\n2023  63.0     85     90   168.0  226.0   339.0   348.0  328.0  342.0\n2024  50.0     92     99   167.0  217.0   332.0   346.0  326.0  339.0\n\n[72 rows x 9 columns]\n      うめ開花  さくら開花  さくら満開  あじさい開花  すすき開花  いちょう黄葉  いちょう落葉  かえで紅葉  かえで落葉   1月  \\\n年                                                                            \n1953  73.0    101    107     NaN    NaN     NaN     NaN    NaN    NaN  0.3   \n1954  62.0     96    102     NaN    NaN     NaN     NaN    NaN    NaN  0.8   \n1955  69.0    101    106     NaN    NaN     NaN     NaN    NaN    NaN  0.6   \n1956  73.0    106    109   156.0    NaN   320.0     NaN  298.0    NaN  0.7   \n1957  97.0    106    111   178.0    NaN   310.0   329.0  301.0  314.0  1.7   \n...    ...    ...    ...     ...    ...     ...     ...    ...    ...  ...   \n2020  60.0     87     93   175.0  208.0   335.0   350.0  327.0  332.0  4.0   \n2021  69.0     87     90   172.0  199.0   334.0   347.0  328.0  335.0  1.2   \n2022  74.0     98    101   178.0  234.0   332.0   343.0  328.0  333.0  1.7   \n2023  63.0     85     90   168.0  226.0   339.0   348.0  328.0  342.0  2.1   \n2024  50.0     92     99   167.0  217.0   332.0   346.0  326.0  339.0  4.2   \n\n      ...    4月    5月    6月    7月    8月    9月   10月   11月  12月   年の値  \n年     ...                                                             \n1953  ...   9.0  13.8  17.1  22.0  22.4  19.3  14.3   6.8  4.2  11.3  \n1954  ...  11.1  14.7  15.8  19.4  24.5  21.6  13.3   8.5  3.6  11.7  \n1955  ...  10.4  14.3  19.9  24.9  24.6  19.3  14.8   7.8  4.8  12.3  \n1956  ...   9.4  14.9  18.6  20.6  22.0  19.9  14.9   8.3  1.4  11.3  \n1957  ...  10.3  14.1  16.7  21.4  24.4  18.8  14.5   9.3  4.6  11.6  \n...   ...   ...   ...   ...   ...   ...   ...   ...   ...  ...   ...  \n2020  ...  10.1  16.8  21.2  21.3  26.6  22.5  15.6  10.8  3.9  13.7  \n2021  ...  11.6  17.0  20.6  24.1  24.9  20.8  15.8  11.1  4.7  13.7  \n2022  ...  11.8  16.5  20.2  24.9  25.1  22.2  15.5  11.9  4.2  13.5  \n2023  ...  13.3  16.6  21.6  26.6  28.6  25.1  16.7  11.4  5.7  15.0  \n2024  ...  14.8  17.8  21.5  26.1  27.4  23.5  18.0  10.9  4.3  14.9  \n\n[72 rows x 22 columns]\n\n\n\nprint(df_temp.index.dtype, df_doy.index.dtype)\nprint(df_temp.index[:5])\nprint(df_doy.index[:5])"
  },
  {
    "objectID": "notebooks/python/秋期間_移動平均.html",
    "href": "notebooks/python/秋期間_移動平均.html",
    "title": "",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n\nfrom meteo_lib.meteo_lib import getBlock, get_HourlyData, get_10minData\nfrom meteo_lib.my_path_utils import DATA, OUT\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.dates import DateFormatter\nimport datetime as dt\nimport matplotlib.dates as mdates\nimport math\nfrom datetime import datetime, timedelta, date, time\nfrom metpy.units import units\nfrom metpy.calc import dewpoint_from_relative_humidity\nimport matplotlib as mpl\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.ticker import FuncFormatter, MultipleLocator\nimport os\nfrom pathlib import Path\nmpl.rcParams[\"font.family\"] = \"IPAexGothic\"   # 例：Noto Sans CJK JP でも可\nmpl.rcParams[\"axes.unicode_minus\"] = False    # －が豆腐になるのを回避\n\n\nsummer_threshold: float = 25.0    # 閾値：夏の終わり\nwinter_threshold: float = 15.0    # 閾値：冬の始まり\n\nplace = '秋田'\nstart_year, end_year = 1927, 2024\n\ndrive_path =Path(\"/Users/takumi/projects/JMA-data/outputs\")\n\ninputpath = drive_path / f'日毎データ_{place}.parquet'\nprint(inputpath)\ndf = pd.read_parquet(inputpath)\n#df = df.reset_index(names='日時')\n\ndf = df.sort_values('日時').reset_index(drop=True)\n\ndf['Tmean_5d'] = df['平均気温'].rolling(window=7, min_periods=5).mean()\ndf['年'] = df['日時'].dt.year\ndf['月'] = df['日時'].dt.month\ndf['日'] = df['日時'].dt.day\ndf = df[(df['年']&gt;=start_year) & (df['年']&lt;=end_year)]\n\nis_summer = (df['Tmean_5d'] &lt; summer_threshold) & (df['月'] &gt;= 9)\nis_winter = (df['Tmean_5d'] &lt; winter_threshold) & (df['月'] &gt;= 9)\nlast_summer = df.loc[is_summer].groupby('年')['日時'].min().rename('Last_Summer')\nfirst_winter = df.loc[is_winter].groupby('年')['日時'].min().rename('First_Winter')\nspan_autumn = ((first_winter - last_summer).dt.days).rename('Span_Autumn')\nidx = pd.Index(range(start_year, end_year + 1), name='年')\nout = pd.concat([last_summer, first_winter, span_autumn],  axis=1).reindex(idx)\nprint(out)\n\n/Users/takumi/projects/JMA-data/outputs/日毎データ_秋田.parquet\n     Last_Summer First_Winter  Span_Autumn\n年                                         \n1927  1927-09-01   1927-09-26           25\n1928  1928-09-12   1928-10-05           23\n1929  1929-09-01   1929-10-14           43\n1930  1930-09-01   1930-10-11           40\n1931  1931-09-01   1931-10-12           41\n...          ...          ...          ...\n2020  2020-09-14   2020-10-18           34\n2021  2021-09-01   2021-10-18           47\n2022  2022-09-01   2022-10-10           39\n2023  2023-09-21   2023-10-22           31\n2024  2024-09-06   2024-10-29           53\n\n[98 rows x 3 columns]\n\n\n\nREF_YEAR = 2001\n\ndef to_refdate(s: pd.Series) -&gt; pd.Series:\n    # 年を消して「月日だけ」を基準年に載せ替え（NaTはNaTのまま）\n    return pd.to_datetime(\n        np.where(s.notna(), s.dt.strftime(f\"{REF_YEAR}\" + \"-%m-%d\"), pd.NaT),\n        errors=\"coerce\"\n    )\n\nfig, ax1 = plt.subplots(figsize=(10, 6))\n\nLast_summer_ref = to_refdate(out[\"Last_Summer\"])\nFirst_winter_ref = to_refdate(out[\"First_Winter\"])\nx = out.index.astype(int).values\n\"\"\"\n# 1) 基準年に投影（回帰・表示を同じ尺度に）\nlast_ref_s = to_refdate(out[\"Last_Summer\"])\nlast_ref_w = to_refdate(out[\"First_Winter\"])\n\n# 2) 欠損除去＆数値化（matplotlibの日付番号へ）\nmask_s = last_ref_s.notna()\nx_fit = out.index[mask_s].astype(int).to_numpy()          # 年（数値）\ny_fit_num_s = mdates.date2num(last_ref_s[mask_s])             # 日付→float\n\nmask_w = last_ref_w.notna()\ny_fit_num_w = mdates.date2num(last_ref_w[mask_s])             # 日付→float\n\"\"\"\n# --- 基準年投影 ---\nlast_ref_s = to_refdate(out[\"Last_Summer\"])\nlast_ref_w = to_refdate(out[\"First_Winter\"])\n\n# --- マスク ---\nmask_s = last_ref_s.notna()\nmask_w = last_ref_w.notna()\n\n# --- X（年：int配列）---\nx_all = out.index.to_numpy(int)\n\n# ===== 左軸：散布 =====\nax1.cla()  # 念のためクリア（他の書式は後で再設定）\nif mask_s.any():\n    ax1.plot(x_all[mask_s], last_ref_s[mask_s], marker='o', linestyle='None',\n             label=f\"&lt; {summer_threshold:.0f} ℃\")\nif mask_w.any():\n    ax1.plot(x_all[mask_w], last_ref_w[mask_w], marker='o', linestyle='None',\n             label=f\"&lt; {winter_threshold:.0f} ℃\")\n\n# ===== 回帰ユーティリティ =====\ndef safe_polyfit(x, dt_series):\n    import numpy as np, matplotlib.dates as mdates\n    y = mdates.date2num(dt_series)\n    x = np.asarray(x, float); y = np.asarray(y, float)\n    m = np.isfinite(x) & np.isfinite(y)\n    if m.sum() &lt; 2:\n        return None\n    a, b = np.polyfit(x[m], y[m], 1)\n    return a, b, mdates.num2date(a * x[m] + b), x[m]\n\n# ===== 夏の回帰（2点以上の時だけ）=====\nres_s = safe_polyfit(x_all[mask_s], last_ref_s[mask_s])\nif res_s:\n    a_s, b_s, y_line_dt_s, x_fit_s = res_s\n    ax1.plot(x_fit_s, y_line_dt_s, '--', label=f\"Fit(S): y={a_s:.3f}x {b_s:+.3f}\")\n\n# ===== 冬の回帰（★夏の x は使わない）=====\nres_w = safe_polyfit(x_all[mask_w], last_ref_w[mask_w])\nif res_w:\n    a_w, b_w, y_line_dt_w, x_fit_w = res_w\n    ax1.plot(x_fit_w, y_line_dt_w, ':', label=f\"Fit(W): y={a_w:.3f}x {b_w:+.3f}\")\n\n# ===== 左軸の体裁 =====\nax1.set_ylabel(\"月日\")\nax1.set_xlabel(\"年\")\nax1.tick_params(axis='x', labelrotation=45)\nax1.set_ylim(pd.Timestamp(REF_YEAR, 7, 1), pd.Timestamp(REF_YEAR+1, 1, 1))\nticks = pd.date_range(start=f\"{REF_YEAR}-09-01\", end=f\"{REF_YEAR+1}-01-01\", freq=\"MS\")\nax1.set_yticks(ticks)\nax1.yaxis.set_major_formatter(mdates.DateFormatter(\"%m-%d\"))\nax1.grid(True, linestyle=\"--\", linewidth=0.5, alpha=0.6)\n\n\n\n# 右軸：秋期間（日）（棒）\nax2 = ax1.twinx()\nax2.bar(x, out['Span_Autumn'].astype(float), alpha=0.3, label=\"秋期間（日）\")\nax2.set_ylabel(\"日数\")\nax2.set_ylim(0, 250)\nticks = list(range(0, 101, 20))\nax2.set_yticks(ticks)\n\na, b = np.polyfit(x, out['Span_Autumn'], 1)\ny = a * x + b\nax2.plot(x, y, linestyle='--', label=f\"Fit: y={a:.3f}x  {b:+.3f}\")\n\n# 凡例（統合）\nhandles, labels = [], []\nfor ax in (ax1, ax2):\n    h, l = ax.get_legend_handles_labels()\n    handles += h; labels += l\nseen, h2, l2 = set(), [], []\nfor h, l in zip(handles, labels):\n    if l not in seen:\n        seen.add(l); h2.append(h); l2.append(l)\n#ax1.legend(h2, l2, loc=\"center left\")\nax1.legend(h2, l2, loc=\"lower center\", ncol=2,\n           facecolor='white', framealpha=1.0)  # ncolで複数列表示\n\nax1.grid(True, linestyle=\"--\", linewidth=0.5, alpha=0.6)\nplt.title(f\"平均気温（5日移動平均）でみた秋期間（日数）  {place}\")\nplt.tight_layout()\n\nplt.savefig(OUT / f'秋期間_移動平均_{place}.png')\n\nplt.show()"
  },
  {
    "objectID": "notebooks/python/秋期間図化.html",
    "href": "notebooks/python/秋期間図化.html",
    "title": "",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n\nfrom meteo_lib import PROJECT  # または: from meteo_lib.paths import PROJECT\nfrom meteo_lib.my_path_utils import DATA, OUT\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.dates import DateFormatter\nimport datetime as dt\nimport matplotlib.dates as mdates\nimport matplotlib as mpl\nmpl.rcParams[\"font.family\"] = \"IPAexGothic\"   # 例：Noto Sans CJK JP でも可\nmpl.rcParams[\"axes.unicode_minus\"] = False    # －が豆腐になるのを回避\n\nimport pymannkendall as mk\n\nplace = '仙台'\nstart_year, end_year = 1926, 2024\nPath = OUT / f'日毎データ_{place}_summary.parquet'\ndf = pd.read_parquet(Path)\n\n\n# ---- 秋期間の図化 ----\n# summary: DataFrame に以下の列があること:\n#   年, 最終夏日, 初冬日, 秋期間\n\nREF_YEAR = 2001\nFALL_COL = \"秋期間\"  # ←計算済みの列名をそのまま使用\n\ndf = df.copy().sort_values(\"年\").reset_index(drop=True)\ndf[\"翌寒候期初冬日\"] = df[\"初冬日\"].shift(-1)  # 折れ線用：翌シーズンの初冬日\n\ndef to_refdate(s: pd.Series) -&gt; pd.Series:\n    # 年を消して「月日だけ」を基準年に載せ替え（NaTはNaTのまま）\n    return pd.to_datetime(\n        np.where(s.notna(), s.dt.strftime(f\"{REF_YEAR}\" + \"-%m-%d\"), pd.NaT),\n        errors=\"coerce\"\n    )\n\nfinal_summer_ref = to_refdate(df[\"最終夏日\"])\nnext_first_winter_ref = to_refdate(df[\"翌寒候期初冬日\"])\nx = df[\"年\"].astype(int).values\n\nfig, ax1 = plt.subplots(figsize=(10, 5))\n\n# 左軸：月日（折れ線）\nax1.plot(x, final_summer_ref, marker=\"o\", color=\"red\", label=\"最終夏日（暦年）\")\nax1.plot(x, next_first_winter_ref, marker=\"s\", color=\"blue\", label=\"翌寒候期初冬日\")\nax1.set_ylabel(\"月日\")\nax1.yaxis.set_major_formatter(DateFormatter(\"%m-%d\"))\nax1.set_xlabel(\"年\")\nx_min, x_max = 2003, 2023    # x軸表示範囲\nax1.set_xlim(x_min, x_max)\nticks = range(int(x_min), int(x_max)+1, 2)\nax1.set_xticks(ticks)\n\nax1.tick_params(axis='x', labelrotation=45)\ny1_min = dt.date(REF_YEAR, 6, 1)\ny1_max = dt.date(REF_YEAR + 1, 1, 1)\nax1.set_ylim(y1_min, y1_max)\n# --- y軸ラベルを9月〜12月の1か月ごとに ---\ntick_dates = pd.date_range(start=f\"{REF_YEAR}-09-01\", end=f\"{REF_YEAR + 1}-01-01\", freq=\"MS\")\n#tick_dates = pd.date_range(start=f\"{REF_YEAR}-09-01\", end=f\"{REF_YEAR}-12-01\", freq=\"MS\")\n\n# --- 回帰用：日付→float（日数）\ny_fit_num_s = mdates.date2num(final_summer_ref)           # NaT → NaN\ny_fit_num_w = mdates.date2num(next_first_winter_ref)      # NaT → NaN\n\n# x が範囲内のマスク\nmask_x = (x &gt;= x_min) & (x &lt;= x_max)\n\n# 欠損を除いたインデックスを作る（少なくとも2点必要）\nmask_s = np.isfinite(y_fit_num_s)\nmask_w = np.isfinite(y_fit_num_w)\n\n# ANDで統合\nmask_s_use = mask_s & mask_x\nmask_w_use = mask_w & mask_x\n\nif mask_s.sum() &gt;= 2:\n    a_s, b_s = np.polyfit(x[mask_s_use], y_fit_num_s[mask_s_use], 1)\n    y_line_num_s = a_s * x + b_s\n    y_line_dt_s  = mdates.num2date(y_line_num_s)\n    ax1.plot(x, y_line_dt_s, linestyle=\"--\", color=\"red\",\n             label=f'y={a_s:.3f}*x  {b_s:+.3f}')\nelse:\n    print(\"最終夏日の回帰は有効データ点が不足のためスキップ\")\n\nif mask_w.sum() &gt;= 2:\n    a_w, b_w = np.polyfit(x[mask_w_use], y_fit_num_w[mask_w_use], 1)\n    y_line_num_w = a_w * x + b_w\n    y_line_dt_w  = mdates.num2date(y_line_num_w)\n    ax1.plot(x, y_line_dt_w, linestyle=\"--\", color=\"blue\",\n             label=f'y={a_w:.3f}*x  {b_w:+.3f}')\nelse:\n    print(\"初冬日の回帰は有効データ点が不足のためスキップ\")\n\nax1.set_yticks(tick_dates)\nax1.yaxis.set_major_formatter(mdates.DateFormatter(\"%m-%d\"))\n\n\n# 右軸：秋期間（日）（棒）\nax2 = ax1.twinx()\ny = pd.to_numeric(df[FALL_COL], errors='coerce').fillna(0.0)\nax2.bar(x, y.values.astype(\"float\"), alpha=0.3, label=\"秋期間（日）\")\nax2.set_ylabel(\"日数\")\nax2.set_ylim(0, 250)\nticks = list(range(0, 101, 20))\nax2.set_yticks(ticks)\n\nx_use = x[mask_x]\ny_use = y[mask_x]\na, b = np.polyfit(x_use, y_use, 1)\ny = a * x + b\nax2.plot(x, y, linestyle=\"--\", label=f'y={a:.3f}*x  {b:+.3f}')\n\n# 凡例（統合）\nhandles, labels = [], []\nfor ax in (ax1, ax2):\n    h, l = ax.get_legend_handles_labels()\n    handles += h; labels += l\nseen, h2, l2 = set(), [], []\nfor h, l in zip(handles, labels):\n    if l not in seen:\n        seen.add(l); h2.append(h); l2.append(l)\nax1.legend(h2, l2, loc=\"lower right\", ncol=2)\n\nax1.grid(True, linestyle=\"--\", linewidth=0.5, alpha=0.6)\nplt.title(f\"最終夏日〜初冬日と秋期間（日数）  {place}\")\nplt.tight_layout()\n\n#plt.savefig(OUT / f'{place}_{start_year}-{end_year}_秋日数.png')\nplt.savefig(OUT / f'{place}_{x_min}-{x_max}_秋日数.png')\n\nplt.show()\n\n\n\n\n\n\n\n\n\n# Theil-Sen estimator\ndef sens_slope(x, t):\n    x = np.asarray(x, dtype=float)\n    t = np.asarray(t, dtype=float)\n    mask = np.isfinite(x) & np.isfinite(t)\n    x = x[mask]\n    t = t[mask]\n    n = len(x)\n    if n &lt; 2:\n        raise ValueError(\"データ点が少なすぎます。\")\n\n    slopes = []\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if t[j] != t[i]:\n                slopes.append((x[j] - x[i]) / (t[j] - t[i]))\n    slopes = np.array(slopes)\n    slope = np.median(slopes)\n    intercept = np.median(x - slope * t)\n    return slope, intercept\n\n\ndef sens_slope_resid_bootstrap_ci(x, t, B=2000, alpha=0.05, random_state=None):\n    \"\"\"\n    Theil–Sen slope の残差ブートストラップ CI（percentile 法）\n\n    Parameters\n    ----------\n    x : array-like\n        観測値（例：秋期間）\n    t : array-like\n        年（例：1950, 1951, ...）\n    B : int\n        ブートストラップ回数\n    alpha : float\n        有意水準（0.05 → 95% CI）\n    random_state : int or None\n        乱数シード（再現性用）\n\n    Returns\n    -------\n    slope0 : float\n        元データでの Theil–Sen slope\n    ci_low : float\n        傾きの下側信頼限界\n    ci_high : float\n        傾きの上側信頼限界\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    t = np.asarray(t, dtype=float)\n    mask = np.isfinite(x) & np.isfinite(t)\n    x = x[mask]\n    t = t[mask]\n    n = len(x)\n    if n &lt; 2:\n        raise ValueError(\"データ点が少なすぎます。\")\n\n    rng = np.random.default_rng(random_state)\n\n    # 1) 元データでの Theil–Sen slope と切片\n    slope0, intercept0 = sens_slope(x, t)\n\n    # 2) 残差を計算\n    y_hat = slope0 * t + intercept0\n    resid = x - y_hat\n\n    # 3) ブートストラップ\n    boot_slopes = np.empty(B)\n    for b in range(B):\n        # 残差を復元抽出\n        e_star = rng.choice(resid, size=n, replace=True)\n\n        # トレンド + 再サンプル残差 で疑似時系列を作る\n        x_star = y_hat + e_star\n\n        # 年はそのまま t を使う → 時系列構造を保持\n        sb, _ = sens_slope(x_star, t)\n        boot_slopes[b] = sb\n\n    # 4) パーセンタイル CI\n    ci_low = np.percentile(boot_slopes, 100 * alpha/2)\n    ci_high = np.percentile(boot_slopes, 100 * (1 - alpha/2))\n\n    print(f\"Sen's slope = {slope0:.3f}\")\n    print(f\"{int((1-alpha)*100)}% CI = [{ci_low:.3f}, {ci_high:.3f}]\")\n\n    return slope0, ci_low, ci_high\n\n\n# Mann-Kendall test\n# start_year–end_year のデータを対象とする\nyear_min = 1950\nyear_max = 2024\nyears = df[\"年\"].to_numpy()\nx = df[\"秋期間\"].to_numpy()\n\nmask_range = (df['年'] &gt;= year_min) & (df['年'] &lt;= year_max)\nmask_al = mask_range & df[\"秋期間\"].notna()\nyears_al = df.loc[mask_al, \"年\"].to_numpy()\nx_al = df.loc[mask_al, \"秋期間\"].to_numpy()\n\nr_o_al = mk.original_test(x_al)\nr_h_al = mk.hamed_rao_modification_test(x_al)\n\nprint(r_o_al)\nprint(r_h_al)\nslope0, lo, hi = sens_slope_resid_bootstrap_ci(\n    x_al, years_al,\n    B=5000, alpha=0.05, random_state=42\n)\n\nMann_Kendall_Test(trend='increasing', h=True, p=0.003025739944670258, z=2.9651107361188873, Tau=0.23546834505738615, s=636.0, var_s=45863.333333333336, slope=0.25, intercept=45.875)\nModified_Mann_Kendall_Test_Hamed_Rao_Approach(trend='increasing', h=True, p=0.000325476769696742, z=3.5941304305404294, Tau=0.23546834505738615, s=636.0, var_s=31214.744428291076, slope=0.25, intercept=45.875)\nSen's slope = 0.250\n95% CI = [0.103, 0.404]\n\n\n\nfrom statsmodels.nonparametric.smoothers_lowess import lowess\n\ndef sens_slope(x, t):\n    x = np.asarray(x, dtype=float)\n    t = np.asarray(t, dtype=float)\n    mask = np.isfinite(x) & np.isfinite(t)\n    x = x[mask]\n    t = t[mask]\n    n = len(x)\n    if n &lt; 2:\n        raise ValueError(\"データ点が少なすぎます。\")\n\n    slopes = []\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if t[j] != t[i]:\n                slopes.append((x[j] - x[i]) / (t[j] - t[i]))\n    slopes = np.array(slopes)\n    slope = np.median(slopes)\n    intercept = np.median(x - slope * t)\n    return slope, intercept\n\n\ndef plot_loess_theilsen(\n    years,\n    values,\n    title=\"\",\n    ylabel=\"\",\n    year_min=None,\n    year_max=None,\n    loess_frac=0.3,\n    outpath=None,\n):\n    \"\"\"\n    年次データに対して\n    ・散布図（観測値）\n    ・LOESS 曲線\n    ・Theil–Sen 直線\n    を重ねて表示する。\n    \"\"\"\n\n    years = np.asarray(years, dtype=float)\n    values = np.asarray(values, dtype=float)\n\n    # NaN 除去\n    mask = np.isfinite(years) & np.isfinite(values)\n    years = years[mask]\n    values = values[mask]\n\n    # 年順にソート\n    order = np.argsort(years)\n    years = years[order]\n    values = values[order]\n\n    if year_min is None:\n        year_min = int(years.min())\n    if year_max is None:\n        year_max = int(years.max())\n\n    # 対象期間だけに絞る\n    mask_period = (years &gt;= year_min) & (years &lt;= year_max)\n    yy = years[mask_period]\n    xx = values[mask_period]\n\n    # Theil–Sen 傾き・切片\n    slope, intercept = sens_slope(xx, yy)\n\n    # LOESS 平滑\n    # lowess は (y, x) の順なので注意\n    loess_res = lowess(xx, yy, frac=loess_frac, it=0, return_sorted=True)\n    loess_x = loess_res[:, 0]  # 年\n    loess_y = loess_res[:, 1]  # 平滑値\n\n    # Theil–Sen 直線用\n    x_line = np.linspace(year_min, year_max, 200)\n    y_line = slope * x_line + intercept\n\n    # プロット\n    fig, ax = plt.subplots(figsize=(7, 4), dpi=150)\n\n    # 観測値\n    ax.plot(yy, xx, \"o\", markersize=4, label=\"観測値\")\n\n    # LOESS 曲線\n    ax.plot(loess_x, loess_y, \"-\", linewidth=2, label=f\"LOESS (frac={loess_frac})\")\n\n    # Theil–Sen 直線\n    ax.plot(x_line, y_line, \"--\", linewidth=2, label=f\"Theil–Sen 直線 (slope={slope:.3f})\")\n\n    ax.set_xlabel(\"年\")\n    ax.set_ylabel(ylabel)\n    if title:\n        ax.set_title(title + f\"（{year_min}–{year_max}）\")\n\n    ax.grid(True, linestyle=\"--\", alpha=0.5)\n    ax.legend(frameon=False, fontsize=9)\n\n    fig.tight_layout()\n\n    if outpath is not None:\n        fig.savefig(outpath, bbox_inches=\"tight\")\n        print(\"→ 図を保存しました:\", outpath)\n\n    return fig, ax, slope\n\n\n# 年でソートしておく\ndf = df.sort_values(\"年\")\n\nmask = (df[\"年\"] &gt;= 1950) & (df[\"年\"] &lt;= 2024)\nyears_al = df.loc[mask, \"年\"].to_numpy()\nx_al     = df.loc[mask, \"秋期間\"].to_numpy()\n\nfig, ax, slope = plot_loess_theilsen(\n    years_al,\n    x_al,\n    title=\"仙台 秋期間の経年変化（LOESS + Theil–Sen）\",\n    ylabel=\"秋期間（日）\",\n    year_min=1950,\n    year_max=2024,\n    loess_frac=0.3,\n    outpath=OUT / \"Sendai_autumn_LOESS_TheilSen_1950_2024.png\",\n)\n\n→ 図を保存しました: /Users/takumi/Projects/JMA-data/outputs/Sendai_autumn_LOESS_TheilSen_1950_2024.png\n\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom statsmodels.nonparametric.smoothers_lowess import lowess\n\ndef plot_loess_theilsen_with_ci(\n    years,\n    values,\n    title=\"\",\n    ylabel=\"\",\n    year_min=None,\n    year_max=None,\n    loess_frac=0.3,\n    B=5000,\n    alpha=0.05,\n    random_state=42,\n    outpath=None,\n):\n    years = np.asarray(years, dtype=float)\n    values = np.asarray(values, dtype=float)\n\n    # NaN 除去\n    mask = np.isfinite(years) & np.isfinite(values)\n    years = years[mask]\n    values = values[mask]\n\n    # 年順にソート\n    order = np.argsort(years)\n    years = years[order]\n    values = values[order]\n\n    if year_min is None:\n        year_min = int(years.min())\n    if year_max is None:\n        year_max = int(years.max())\n\n    # 対象区間\n    mask_period = (years &gt;= year_min) & (years &lt;= year_max)\n    yy = years[mask_period]\n    xx = values[mask_period]\n\n    # --- Theil–Sen slope と CI ---\n    slope0, intercept0 = sens_slope(xx, yy)\n\n    # 中央年でアンカー\n    t0 = yy.mean()\n    y0 = slope0 * t0 + intercept0\n\n    # ブートストラップで CI\n    slope0_bs, ci_low, ci_high = sens_slope_resid_bootstrap_ci(\n        xx, yy, B=B, alpha=alpha, random_state=random_state\n    )\n    slope0 = slope0_bs\n\n    # x 軸\n    x_line = np.linspace(year_min, year_max, 200)\n\n    # 3 本の線（中心年 t0 で揃える）\n    y_mid  = y0 + slope0 * (x_line - t0)\n    y_low  = y0 + ci_low  * (x_line - t0)\n    y_high = y0 + ci_high * (x_line - t0)\n\n    # --- LOESS ---\n    loess_res = lowess(xx, yy, frac=loess_frac, it=0, return_sorted=True)\n    loess_x = loess_res[:, 0]\n    loess_y = loess_res[:, 1]\n\n    # --- 図作成（ここで初めて ax が出てくる） ---\n    fig, ax = plt.subplots(figsize=(7, 4), dpi=150)\n\n    # CI 帯\n    ax.fill_between(x_line, y_low, y_high, alpha=0.15, label=\"Theil–Sen 95% CI\")\n\n    # 中央線\n    ax.plot(x_line, y_mid, \"--\", lw=2, label=f\"Theil–Sen 直線 (slope={slope0:.3f})\")\n\n    # LOESS\n    ax.plot(loess_x, loess_y, \"-\", lw=2, label=f\"LOESS (frac={loess_frac})\")\n\n    # 観測値\n    ax.plot(yy, xx, \"o\", markersize=4, label=\"観測値\")\n\n    ax.set_xlabel(\"年\")\n    ax.set_ylabel(ylabel)\n    ax.set_title(f\"{title}（{year_min}–{year_max}）\")\n    ax.grid(True, linestyle=\"--\", alpha=0.5)\n    ax.legend(frameon=False)\n\n    fig.tight_layout()\n\n    if outpath is not None:\n        fig.savefig(outpath, bbox_inches=\"tight\")\n        print(\"→ 図を保存しました:\", outpath)\n\n    return fig, ax, slope0, ci_low, ci_high\n\n\n# 年でソートしておく\ndf = df.sort_values(\"年\")\n\nmask = (df[\"年\"] &gt;= 1950) & (df[\"年\"] &lt;= 2024)\nyears_al = df.loc[mask, \"年\"].to_numpy()\nx_al     = df.loc[mask, \"秋期間\"].to_numpy()\n\nfig, ax, slope0, lo, hi = plot_loess_theilsen_with_ci(\n    years_al,\n    x_al,\n    title=\"仙台 秋期間の経年変化（LOESS + Theil–Sen + 95%CI）\",\n    ylabel=\"秋期間（日）\",\n    year_min=1950,\n    year_max=2024,\n    loess_frac=0.3,\n    B=5000,\n    alpha=0.05,\n    random_state=42,\n    outpath=OUT / \"Sendai_autumn_LOESS_TheilSen_CI_1950_2024.png\",\n)\n\nprint(\"Sen's slope =\", slope0)\nprint(\"95% CI =\", lo, hi)\n\nSen's slope = 0.250\n95% CI = [0.103, 0.404]\n→ 図を保存しました: /Users/takumi/Projects/JMA-data/outputs/Sendai_autumn_LOESS_TheilSen_CI_1950_2024.png\nSen's slope = 0.25\n95% CI = 0.10344359070464768 0.4044307809330626\n\n\n\n\n\n\n\n\n\n\n# ---- 春期間の図化 ----\n# summary: DataFrame に以下の列があること:\n#   年, 最終冬日, 初夏日, 春期間\n\nREF_YEAR = 2001\nFALL_COL = \"春期間\"  # ←計算済みの列名をそのまま使用\n\ndf = df.copy().sort_values(\"年\").reset_index(drop=True)\n#df[\"翌寒候期初冬日\"] = df[\"初冬日\"].shift(-1)  # 折れ線用：翌シーズンの初冬日\n\ndef to_refdate(s: pd.Series) -&gt; pd.Series:\n    # 年を消して「月日だけ」を基準年に載せ替え（NaTはNaTのまま）\n    return pd.to_datetime(\n        np.where(s.notna(), s.dt.strftime(f\"{REF_YEAR}\" + \"-%m-%d\"), pd.NaT),\n        errors=\"coerce\"\n    )\n\nfinal_winter_ref = to_refdate(df[\"最終冬日\"])\nfirst_summer_ref = to_refdate(df[\"初夏日\"])\nx = df[\"年\"].astype(int).values\n\nx_min = 2003\nx_max = 2023\n# x が範囲内のマスク\nmask_x = (x &gt;= x_min) & (x &lt;= x_max)\n\nfig, ax1 = plt.subplots(figsize=(10, 5))\n\n# 左軸：月日（折れ線）\n# y は datetime（NaT を含む想定）\nax1.plot(x, final_winter_ref, marker=\"o\", color=\"blue\", label=\"最終冬日\")\n\nax1.set_xlim(x_min, x_max)\nticks = range(int(x_min), int(x_max)+1, 2)\nax1.set_xticks(ticks)\n\ny_dt = pd.to_datetime(final_winter_ref)\n# 欠損を除外し、x と y の長さを揃える\nmask = y_dt.notna() & mask_x\nx_fit = np.asarray(x, dtype=float)[mask]\ny_fit = mdates.date2num(y_dt[mask])   # ← 日付 → float（日単位）\n\n# 点が2つ以上ある時だけ回帰\nif x_fit.size &gt;= 2:\n    a, b = np.polyfit(x_fit, y_fit, 1)\n    y_line = a * x_fit + b\n    # 描画は datetime に戻す\n    ax1.plot(x_fit, mdates.num2date(y_line), color=\"blue\", linestyle=\"--\",\n             label=f\"y={a:.3f}*x {b:+.3f}\")\nelse:\n    print(\"[DEBUG] winter fit skipped (&lt;2 points)\")\n\nax1.plot(x, first_summer_ref, marker=\"s\", color=\"red\", label=\"初夏日\")\n\n# y は datetime（NaT を含む想定）\ny_dt = pd.to_datetime(first_summer_ref)\n\n# 欠損を除外し、x と y の長さを揃える\nmask = y_dt.notna() & mask_x\nx_fit = np.asarray(x, dtype=float)[mask]\ny_fit = mdates.date2num(y_dt[mask])   # ← 日付 → float（日単位）\n\n# 点が2つ以上ある時だけ回帰\nif x_fit.size &gt;= 2:\n    a, b = np.polyfit(x_fit, y_fit, 1)\n    y_line = a * x_fit + b\n    # 描画は datetime に戻す\n    ax1.plot(x_fit, mdates.num2date(y_line), color=\"red\", linestyle=\"--\",\n             label=f\"y={a:.3f}*x {b:+.3f}\")\nelse:\n    print(\"[DEBUG] winter fit skipped (&lt;2 points)\")\n\nax1.set_ylabel(\"月日\")\nax1.yaxis.set_major_formatter(DateFormatter(\"%m-%d\"))\nax1.set_xlabel(\"年\")\nax1.tick_params(axis='x', labelrotation=45)\ny1_min = dt.date(REF_YEAR - 1, 12, 1)\ny1_max = dt.date(REF_YEAR, 7, 1)\nax1.set_ylim(y1_min, y1_max)\n# --- y軸ラベルを3月〜6月の1か月ごとに ---\ntick_dates = pd.date_range(start=f\"{REF_YEAR}-02-01\", end=f\"{REF_YEAR}-07-01\", freq=\"MS\")\n#tick_dates = pd.date_range(start=f\"{REF_YEAR}-09-01\", end=f\"{REF_YEAR}-07-01\", freq=\"MS\")\nax1.set_yticks(tick_dates)\nax1.yaxis.set_major_formatter(mdates.DateFormatter(\"%m-%d\"))\n\n\n# 右軸：春期間（日）（棒）\nax2 = ax1.twinx()\ny = pd.to_numeric(df[FALL_COL], errors='coerce').fillna(0.0)\nax2.bar(x, y.values.astype(\"float\"), alpha=0.3, label=\"春期間（日）\")\nx = x[mask_x]\ny = y[mask_x]\na, b = np.polyfit(x, y.values.astype(\"float\"), 1)\ny = a * x + b\nax2.plot(x, y, linestyle=\"--\", label=f'y={a:.3f}*x  {b:+.3f}')\n\nax2.set_ylabel(\"日数\")\nax2.set_ylim(0, 250)\nticks = list(range(0, 101, 20))\nax2.set_yticks(ticks)\n\n\n# 凡例（統合）\nhandles, labels = [], []\nfor ax in (ax1, ax2):\n    h, l = ax.get_legend_handles_labels()\n    handles += h; labels += l\nseen, h2, l2 = set(), [], []\nfor h, l in zip(handles, labels):\n    if l not in seen:\n        seen.add(l); h2.append(h); l2.append(l)\n#ax1.legend(h2, l2, loc=\"best\")\nax1.legend(h2, l2, loc='lower left')\n\nax1.grid(True, linestyle=\"--\", linewidth=0.5, alpha=0.6)\nplt.title(f\"最終冬日〜初夏日と春期間（日数）  {place}\")\nplt.tight_layout()\n\nplt.savefig(OUT / f'{place}_{start_year}-{end_year}_春日数.png')\n\nplt.show()\n\n\n\n\n\n\n\n\n\n# ---- 夏日・真夏日・猛暑日の推移 ----\n# summary: DataFrame に以下の列があること:\n#   年, 夏日日数, 真夏日日数, 猛暑日日数\n\ndf = df.copy().sort_values(\"年\").reset_index(drop=True)\n\nfig, axes = plt.subplots(nrows=3, ncols=1, figsize=(10, 12), sharex=True)\n\nlabels = [\"夏日\", \"真夏日\", \"猛暑日\"]\ncolors = [\"skyblue\", \"lightgreen\", \"salmon\"]\n\nfor ax, col, lab in zip(axes, [\"夏日日数\", \"真夏日日数\", \"猛暑日日数\"], labels):\n    ax.bar(df[\"年\"], df[col], color=colors.pop(0), label=lab)\n    a, b = np.polyfit(df[\"年\"], df[col], 1)\n    y = a * x + b\n    ax.plot(x, y, linestyle=\"--\", label=f'y={a:.3f}*x  {b:+.3f}')\n\n    ax.set_ylabel(\"日数\")\n    ax.legend()\n\nfig.suptitle(f'夏日日数〜猛暑日日数 ／ {place}', fontsize=16, y=0.95)\nfig.tight_layout(rect=[0, 0, 1, 0.96])\nplt.savefig(OUT / f'{place}_{start_year}-{end_year}_夏日日数.png')\nplt.show()\n#fig\n\n\n\n\n\n\n\n\n\n# ---- 冬日・真冬日の日数 ----\n# summary: DataFrame に以下の列があること:\n#   年, 冬日日数, 真冬日日数\n\ndf = df.copy().sort_values(\"年\").reset_index(drop=True)\n\nfig, axes = plt.subplots(nrows=2, ncols=1, figsize=(10, 8), sharex=True)\n\nlabels = [\"冬日\", \"真冬日\"]\ncolors = [\"skyblue\", \"lightgreen\"]\n\nfor ax, col, lab in zip(axes, [\"冬日日数\", \"真冬日日数\"], labels):\n    ax.bar(df[\"年\"], df[col], color=colors.pop(0), label=lab)\n    a, b = np.polyfit(df[\"年\"], df[col], 1)\n    y = a * x + b\n    ax.plot(x, y, linestyle=\"--\", label=f'y={a:.3f}*x  {b:+.3f}')\n\n    ax.set_ylabel(\"日数\")\n    ax.legend()\n\nfig.suptitle(f'冬日日数・真冬日日数 ／ {place}', fontsize=16, y=0.95)\nfig.tight_layout(rect=[0, 0, 1, 0.96])\nplt.savefig(OUT / f'{place}_{start_year}-{end_year}_冬日日数.png')\nplt.show()\n#fig"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "「秋の長さ」に関する解析レポート",
    "section": "",
    "text": "2026年2月例会:生物季節観測"
  },
  {
    "objectID": "index.html#公開資料",
    "href": "index.html#公開資料",
    "title": "「秋の長さ」に関する解析レポート",
    "section": "",
    "text": "2026年2月例会:生物季節観測"
  },
  {
    "objectID": "notebooks/python/生物季節観測r2.html",
    "href": "notebooks/python/生物季節観測r2.html",
    "title": "",
    "section": "",
    "text": "生物気象観測\n\n%load_ext autoreload\n%autoreload 2\n\nimport sys\nfrom pathlib import Path\n\ndef add_project_root(marker=\"project_paths.py\") -&gt; Path:\n    p = Path.cwd().resolve()\n    for d in [p, *p.parents]:\n        if (d / marker).exists():\n            sys.path.insert(0, str(d))\n            return d\n    raise FileNotFoundError(f\"Could not find {marker} from cwd={p}\")\n\nPROJECT_ROOT = add_project_root()\nprint(\"Project root:\", PROJECT_ROOT)\n\nfrom project_paths import ROOT as PROJECT, JMA_DATA, OUT, FIG, TAB, REP, CFG\nfrom project_paths import OUT\n#out_dir = OUT / \"JMA_data\"\nfrom meteo_lib.core import getBlock, get_HourlyData, get_10minData\nfrom meteo_lib.paths import JMA_DATA, JMA_GPV_DATA, ERA5_DATA, CACHE_DIR\n\nprint(\"Data root:\",JMA_DATA)\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\nProject root: /Users/takumi/Projects/meteo-analysis/JMA\nData root: /Users/takumi/Projects/MetData/JMA\n\n\n\nimport numpy as np\nimport pandas as pd\nimport math\nfrom datetime import datetime, timedelta, date, time\nimport calendar\nimport os\nfrom pathlib import Path\n\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.rcParams[\"font.family\"] = \"Hiragino Sans\"   # 例：Noto Sans CJK JP でも可\nmpl.rcParams[\"axes.unicode_minus\"] = False    # －が豆腐になるのを回避\nimport matplotlib.dates as mdates\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.ticker import FuncFormatter, MultipleLocator\n\nfrom metpy.units import units\nfrom metpy.calc import dewpoint_from_relative_humidity\nfrom IPython.display import display \n\n\ndef datetime_value(x, column_value):\n\n    year = column_value  # 本来の年\n    #  year = 2000  # 図化のため2000年に揃える\n    if not np.isnan(x): x = int(x)\n    #  print('ｘ ', year, x)\n    if pd.notna(x):  # 欠測値には0が入力されている\n        mon, day = np.divmod(x, 100)\n#        print(mon, day)\n        date_string = f\"{year}-{mon}-{day}\"\n        date = pd.to_datetime(date_string, format='%Y-%m-%d')\n        return date\n    else:\n        return  pd.NaT\n\n\n# 生物季節観測のcsvファイルを読み込む\ndef read_data(fn):\n    cs1 = ['rm', '番号']\n    cs2 = ['平年値', '最早値', '最晩値', '最早年', '最晩年']\n    end_year = 2024\n\n#    print(fn)\n    title_row = pd.read_csv(fn, encoding='shift-jis', nrows=1, header=None).iloc[0,1]\n    df = pd.read_csv(fn, header=1, encoding='shift-JIS',\n                 usecols=lambda column: all(substring not in column for substring in cs1),\n                 index_col='地点名')\n\n    df = df.drop(columns=cs2)\n    df = df.drop(df.columns[df.columns&gt;str(end_year)], axis=1)\n    df.index = df.index.str.strip()  # indexから空白文字を削除\n    df = df.where(df&gt;=100, other=np.nan)\n#    display(df)\n\n    for col in df.columns:\n        if col=='1969': print('統計値', col, df[col].max(), df[col].min())\n        if (df[col].median() &lt; 1000) and (df[col] &gt; 1000).any():\n            df[col] = df[col].apply(datetime_value, args=(df[col].name,))\n            df[col] = df[col] - timedelta(days=365)\n#      print(col, df[col], \"timedelta\")\n        else:\n            df[col] = df[col]\n            df[col] = df[col].apply(datetime_value, args=(df[col].name,))\n#            print(col, df[col])\n\n    df = df.transpose()  # 行と列を入れ替える\n    df.index.name = '年'\n\n    return df, title_row\n\n\nfp = JMA_DATA / 'raw/生物季節観測'\n\nsubject = {'うめ開花':1, 'さくら開花':4, 'さくら満開':5, 'あじさい開花':9, 'すすき開花':11,\n           'いちょう黄葉':13, 'いちょう落葉':14,'かえで紅葉':15,'かえで落葉':16, 'うぐいす初鳴':18,\n           'つばめ初見':19, 'とのさまがえる初見':22, 'あぶらぜみ初鳴':25, 'りんご開花':91, 'みんみんぜみ初鳴':119}\n\nsub = 'いちょう黄葉'\nsub_no = str(subject[sub]).zfill(3)\nfn = fp / f'{sub_no}{sub}.csv'\nprint(\"file name:\", fn)\n# DataFrameを読み込んで列名を変更し、連結する\ndf, title_row = read_data(fn)\ndisplay(df)\n\nfile name: /Users/takumi/Projects/MetData/JMA/raw/生物季節観測/013いちょう黄葉.csv\n統計値 1969 1204.0 1013.0\n\n\n\n\n\n\n\n\n地点名\n稚内\n留萌\n旭川\n網走\n札幌\n岩見沢\n帯広\n釧路\n根室\n室蘭\n...\n徳島\n名瀬\n与那国島\n西表島\n石垣島\n宮古島\n久米島\n那覇\n名護\n南大東島\n\n\n年\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1953\nNaT\nNaT\nNaT\nNaT\n1953-10-15\nNaT\nNaT\nNaT\nNaT\nNaT\n...\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\n\n\n1954\nNaT\nNaT\nNaT\n1954-10-12\n1954-10-26\nNaT\nNaT\nNaT\nNaT\nNaT\n...\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\n\n\n1955\nNaT\nNaT\nNaT\n1955-10-12\n1955-11-02\nNaT\nNaT\nNaT\nNaT\nNaT\n...\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\n\n\n1956\nNaT\nNaT\nNaT\nNaT\n1956-11-01\nNaT\nNaT\nNaT\nNaT\nNaT\n...\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\n\n\n1957\nNaT\nNaT\nNaT\nNaT\n1957-11-02\nNaT\nNaT\nNaT\nNaT\nNaT\n...\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2020\nNaT\nNaT\nNaT\nNaT\n2020-11-02\nNaT\n2020-10-31\nNaT\nNaT\nNaT\n...\n2020-12-08\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\n\n\n2021\nNaT\nNaT\nNaT\nNaT\n2021-10-29\nNaT\n2021-10-29\nNaT\nNaT\nNaT\n...\n2021-12-02\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\n\n\n2022\nNaT\nNaT\nNaT\nNaT\n2022-11-04\nNaT\n2022-11-06\nNaT\nNaT\nNaT\n...\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\n\n\n2023\nNaT\nNaT\nNaT\nNaT\n2023-11-05\nNaT\n2023-11-02\nNaT\nNaT\nNaT\n...\n2023-12-04\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\n\n\n2024\nNaT\nNaT\nNaT\nNaT\n2024-11-12\nNaT\n2024-11-05\nNaT\nNaT\nNaT\n...\n2024-12-12\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\nNaT\n\n\n\n\n72 rows × 102 columns\n\n\n\n\ndef to_refdate(s: pd.Series, ref_year: int) -&gt; pd.Series:\n    # 入力をまず datetime に統一（object混在対策）\n    s = pd.to_datetime(s, errors=\"coerce\")\n    mask = s.notna()\n\n    # いったん全NaTの Series を用意\n    out = pd.Series(pd.NaT, index=s.index, dtype=\"datetime64[ns]\")\n\n    # 有効値のみ、月日を取り出して基準年で生成\n    if mask.any():\n        out.loc[mask] = pd.to_datetime({\n            \"year\":  np.full(mask.sum(), ref_year, dtype=int),\n            \"month\": s.loc[mask].dt.month,\n            \"day\":   s.loc[mask].dt.day\n        }, errors=\"raise\")  # ref_yearが平年のとき2/29でエラーにしたいなら \"raise\"\n    return out\n\n\nREF_YEAR = 2001\n\nimport seaborn as sns\n\nplace = ('青森', '秋田', '盛岡', '山形', '仙台', '福島')\nfig = plt.figure(figsize=(10,8), tight_layout=True)\nsns.set(style='whitegrid', context='talk', font_scale=1.0, font='Hiragino Sans')\nax1 = fig.add_subplot(1,1,1)\nmonth_min, month_max = 9, 12\ndays = calendar.monthrange(REF_YEAR, month_max)[1]\ny_min, y_max = f'{REF_YEAR}/{month_min}/1', f'{REF_YEAR}/{month_max}/{days}'\ny_span = pd.to_datetime([y_min, y_max])\nax1.set_ylim(y_span)\ny_df = pd.DataFrame({p: to_refdate(df[p], REF_YEAR) for p in place})\n#print(y_df)\n\nmarkers = [\"D\", \"o\", \"s\", \"^\", \"v\", \"P\"]   # 好きに増やせる\ncolors  = [\"tab:blue\", \"tab:orange\", \"tab:green\", \n           \"tab:red\", \"tab:purple\", \"tab:brown\"]\nfor p, m, c in zip(place, markers, colors):\n    sns.lineplot(\n        x=y_df.index, y=y_df[p], \n        linestyle='-', color=c,\n        marker=m, label=p, ax=ax1)\n\nax1.set(title=title_row, xlabel='年', ylabel=title_row)\nplt.gca().yaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))\n\nplt.xticks(df.index[::5])  #　x軸ラベルの表示間隔を5に指定\nplt.xticks(rotation=45)  # ラベルを45度回転させる\n\nhandles, labels = ax1.get_legend_handles_labels()\nax1.legend(handles, labels, ncol=len(labels), loc=\"upper center\", fontsize=14)\n\n#plt.legend()\nplt.savefig(OUT / f'{fp}{sub}.png')\nplt.show()\n\n\n\n\n\n\n\n\n\n# ===== 入力パラメータ =====\nREF_YEAR = 2001\nplace    = '仙台'\nsub      = ('かえで紅葉', 'かえで落葉')\n#sub      = ('さくら開花', 'あじさい開花')\nsubject  = {'うめ開花':1, 'さくら開花':4, 'さくら満開':5, 'あじさい開花':9, 'すすき開花':11,\n            'いちょう黄葉':13, 'いちょう落葉':14,'かえで紅葉':15,'かえで落葉':16, 'うぐいす初鳴':18,\n            'つばめ初見':19, 'とのさまがえる初見':22, 'あぶらぜみ初鳴':25, 'りんご開花':91, 'みんみんぜみ初鳴':119}\n\nfp = JMA_DATA / 'raw/生物季節観測'\nprint(fp)\n\n# === 入力CSVパス ===\nsub_no_lst = [str(subject[s]).zfill(3) for s in sub]\nfn_lst = [fp / f\"{no}{name}.csv\" for no, name in zip(sub_no_lst, sub)]\n\n# === 読み込み（read_data は (df, title) を返す想定：列=地点名, 行=年, subject列を付ける） ===\nparts = []\nfor name, path in zip(sub, fn_lst):\n    df_i, title_i = read_data(path)      # df_i: index=年, columns=地点名, 値=日付\n    ser_place = df_i[place].rename(\"date\")     # 1地点だけ取り出す → Series\n    tmp = ser_place.to_frame().reset_index().rename(columns={\"index\": \"年\"})\n    tmp[\"subject\"] = name\n    parts.append(tmp)\n\n#print(\"parts:\", parts)\n\ndf_long = pd.concat(parts, ignore_index=True)  # 列: 年, date, subject\n\n# 年をx、同じ年の「月日だけ」をREF_YEARにそろえたdateをyとして描く\ndf_long[\"refdate\"] = to_refdate(df_long[\"date\"], REF_YEAR)\nprint(\"df_long\", df_long)\n\nfn = f\"{place}_{sub[0]}_{sub[1]}.csv\"\nprint(fn)\ndf_long.to_csv(OUT / fn, index=False)\n\n# === プロット ===\nsns.set(style='whitegrid', context='talk')\nplt.rcParams['font.family'] = 'Hiragino Sans'\n\nfig, ax = plt.subplots(figsize=(10, 8))\ndf_long['年'] = pd.to_numeric(df_long['年'], errors='coerce')\n#print(df_long.dtypes)\nax.set_xlim(2000, 2024)\nax.set_xticks(range(2000,2024,10))\nmonth_min, month_max = 9, 12\ndays = calendar.monthrange(REF_YEAR, month_max)[1]\ny_min = pd.to_datetime([f'{REF_YEAR}/{month_min}/1']),\ny_max = pd.to_datetime([f'{REF_YEAR}/{month_max}/{days}']) + timedelta(days=1)\nax.set_ylim(y_min, y_max)\n#ax.set_ylim(pd.to_datetime([f'{REF_YEAR}/{month_min}/1', f'{REF_YEAR}/{month_max}/{days}']))\nsns.lineplot(\n    data=df_long.sort_values([\"subject\", \"年\"]),\n    x=\"年\", y=\"refdate\", hue=\"subject\", style=\"subject\",\n    markers=True, dashes=False, ax=ax\n)\n\nax.yaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))\nax.set_title(f\"{place}：{sub[0]} と {sub[1]}\")\nax.set_xlabel(\"年\"); ax.set_ylabel(\"観測日（MM/DD, 基準年置換）\")\n#sns.move_legend(ax, \"upper center\", bbox_to_anchor=(0.5, 1.12), ncol=len(sub), frameon=False)\nsns.move_legend(ax, \"upper center\", title=None)\nplt.tight_layout()\nplt.show()\n\n/Users/takumi/Projects/MetData/JMA/raw/生物季節観測\n統計値 1969 1201.0 1002.0\n統計値 1969 1227.0 1027.0\ndf_long         年       date subject    refdate\n0    1953        NaT   かえで紅葉        NaT\n1    1954        NaT   かえで紅葉        NaT\n2    1955        NaT   かえで紅葉        NaT\n3    1956 1956-10-25   かえで紅葉 2001-10-25\n4    1957 1957-10-28   かえで紅葉 2001-10-28\n..    ...        ...     ...        ...\n139  2020 2020-11-28   かえで落葉 2001-11-28\n140  2021 2021-12-01   かえで落葉 2001-12-01\n141  2022 2022-11-29   かえで落葉 2001-11-29\n142  2023 2023-12-08   かえで落葉 2001-12-08\n143  2024 2024-12-05   かえで落葉 2001-12-05\n\n[144 rows x 4 columns]\n仙台_かえで紅葉_かえで落葉.csv\n\n\n\n\n\n\n\n\n\n\nimport pandas as pd\n\n# まず安全に datetime 化（既に datetime ならこの行は不要）\n#df['refdate'] = pd.to_datetime(df['refdate'], errors='coerce')\n\n# 年×subject を横持ち（wide）に\nw = (df_long\n     .dropna(subset=['refdate'])        # refdate がない行は除外（任意）\n     .pivot_table(index='年', columns='subject', values='refdate', aggfunc='first')\n     .rename_axis(None, axis=1))\n\n# 黄葉〜落葉の日数（落葉 - 黄葉）\nw[f'{sub[0]}-{sub[1]}_日数'] = (w.get(sub[1]) - w.get(sub[0])).dt.days\n\n# 欲しければ結果を tidy に戻すか、列を選んで表示\nresult = w[[sub[0], sub[1], f'{sub[0]}-{sub[1]}_日数']].reset_index()\nprint(result.head())\n\n      年      かえで紅葉      かえで落葉  かえで紅葉-かえで落葉_日数\n0  1956 2001-10-25        NaT             NaN\n1  1957 2001-10-28 2001-11-10            13.0\n2  1958 2001-11-01        NaT             NaN\n3  1959 2001-11-20 2001-12-05            15.0\n4  1960 2001-11-05 2001-11-26            21.0\n\n\n\n# 前提: w は index=年、列=['いちょう黄葉','いちょう落葉','黄葉→落葉_日数']\n# いちょう黄葉・落葉は \"2001-..-..\" の refdate（日付）である想定\nx_min, x_max = 1971, 2024\n\nw = w.copy()\nw[sub[0]] = pd.to_datetime(w[sub[0]], errors='coerce')\nw[sub[1]] = pd.to_datetime(w[sub[1]], errors='coerce')\n\n# y軸用に matplotlib の内部日付数値へ変換（NaTは除外マスクで処理）\ny_koyo = mdates.date2num(w[sub[0]])\ny_rakuyo = mdates.date2num(w[sub[1]])\n\nfig, ax1 = plt.subplots(figsize=(11,7))\n\n# --- 折れ線（左y軸：月日表示） ---\nmask_k = (~w[sub[0]].isna()) & (w.index &gt; x_min) & (w.index &lt; x_max)\nmask_r = (~w[sub[1]].isna()) & (w.index &gt; x_min) & (w.index &lt; x_max)\n\nax1.plot(w.index[mask_k], y_koyo[mask_k], marker='o', \n         color='red', label=sub[0])\nax1.plot(w.index[mask_r], y_rakuyo[mask_r], marker='o', \n         color='orange', label=sub[1])\n\nax1.set_xlabel('年')\nax1.set_ylabel('月日')\nax1.set_xlim(x_min, x_max)\n\nax1.set_xticks(range(x_min,x_max,10))\ny1_min = pd.to_datetime(f'{REF_YEAR}/10/1')\ny1_max = pd.to_datetime(f'{REF_YEAR}/12/31')\nax1.set_ylim(y1_min, y1_max)\n\na_k, b_k = np.polyfit(w.index[mask_k], y_koyo[mask_k], 1)\ny_line_num_k = a_k * w.index + b_k\ny_line_dt_k  = mdates.num2date(y_line_num_k)\nax1.plot(w.index, y_line_dt_k, linestyle=\"--\", color=\"red\",\n         label=f'y={a_k:.3f}*x  {b_k:+.3f}')\n\na_r, b_r = np.polyfit(w.index[mask_r], y_rakuyo[mask_r], 1)\ny_line_num_r = a_r * w.index + b_r\ny_line_dt_r  = mdates.num2date(y_line_num_r)\nax1.plot(w.index, y_line_dt_r, linestyle=\"--\", color=\"orange\",\n         label=f'y={a_r:.3f}*x  {b_r:+.3f}')\n\n# y軸を月日表示にする（アンカー年は 2001 年想定）\nax1.yaxis.set_major_formatter(mdates.DateFormatter('%m-%d'))\nax1.yaxis.set_major_locator(mdates.MonthLocator(bymonthday=1))  # 毎月1日\n# 表示範囲（必要に応じて調整。秋〜冬に絞る例）\n#ymin = mdates.date2num(pd.Timestamp('2001-09-01'))\n#ymax = mdates.date2num(pd.Timestamp('2001-12-20'))\nax1.set_ylim(y1_min, y1_max)\n#ax1.grid(True, axis='y', alpha=0.3)\n\n# --- 第2y軸：棒グラフ（黄葉→落葉 日数） ---\nax2 = ax1.twinx()\ny_d = w[f'{sub[0]}-{sub[1]}_日数']\n#print(y_d[mask_k])\nax2.bar(w.index[mask_k], y_d[mask_k], color='blue',\n        alpha=0.35, label=f'{sub[0]}〜{sub[1]} 日数')\nax2.set_ylabel('日数')\nax2.set_ylim(0, 300)\n\n#x_num = mdates.date2num(w.index[mask_k])\nx_num = w.index[mask_k]\ny_num = y_d[mask_k]\na_d, b_d = np.polyfit(x_num, y_num, 1)\n#x_all = mdates.date2num(w.index)\nx_all = w.index\ny_line = a_d * x_all + b_d\nax2.plot(w.index, y_line, linestyle=\"--\", color=\"blue\",\n         label=f'y={a_d:.3f}*x  {b_d:+.3f}')\n\n# 凡例（左右の軸ハンドルを結合）\nh1, l1 = ax1.get_legend_handles_labels()\nh2, l2 = ax2.get_legend_handles_labels()\nleg = ax1.legend(h1+h2, l1+l2, fontsize=12,\n                 loc='center right', title=None)  # タイトルは出さない\n\n#plt.title(f'{sub[0]}・{sub[1]}（左：月日）と{sub[0]}-{sub[1]}期間（右：日数）')\nplt.title(f'{sub[0]}〜{sub[1]} ／ {place}')\nplt.tight_layout()\nplt.savefig(OUT / f'{place}_{sub[0]}-{sub[1]}.png')\nplt.show()"
  },
  {
    "objectID": "notebooks/python/秋の長さ_体感温度.html",
    "href": "notebooks/python/秋の長さ_体感温度.html",
    "title": "",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n\nfrom meteo_lib import PROJECT  # または: from meteo_lib.paths import PROJECT\n#out_dir  = PROJECT / \"outputs\"\n\nfrom meteo_lib.meteo_lib import getBlock, get_HourlyData, get_10minData\nfrom meteo_lib.my_path_utils import DATA, OUT\n\nimport pandas as pd\nimport math\nimport numpy as np\nfrom datetime import datetime, timedelta, date, time\nfrom metpy.units import units\nfrom metpy.calc import dewpoint_from_relative_humidity\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.rcParams[\"font.family\"] = \"Hiragino Sans\"   # 例：Noto Sans CJK JP でも可\nmpl.rcParams[\"axes.unicode_minus\"] = False    # －が豆腐になるのを回避\n\nimport matplotlib.dates as mdates\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.ticker import FuncFormatter, MultipleLocator\nimport os\nfrom pathlib import Path\nimport calendar\nfrom IPython.display import display \n\n\n# ---- BOM式 Apparent Temperature ----\ndef apparent_temperature(T, V, e=None, RH=None):\n    if e is None:\n        if RH is None:\n            return pd.Series(np.nan, index=T.index)\n        e = 6.105 * np.exp((17.27*T)/(237.7+T)) * (RH/100.0)  # hPa\n    return T + 0.33*e - 0.70*V - 4.00\n\n\n# Apparent Temperature の中央値を求める\ndef get_AT_median(s: pd.Series, t_min: pd.Timestamp, t_max: pd.Timestamp):\n    s = pd.to_numeric(s, errors='coerce')\n    idx = pd.to_datetime(s.index, errors='coerce')\n    s = s.loc[idx.notna()]\n    m = (s.index &gt;= t_min) & (s.index &lt;= t_max)\n#    print(s.loc[m])\n    return float(s.loc[m].median(skipna=True)) if m.any() else None\n\n\ndef DataConversion(df: pd.DataFrame, add_column: bool = False) -&gt; pd.DataFrame:\n    # 1) 日時→DatetimeIndex\n    if '日時' in df.columns:\n        df['日時'] = pd.to_datetime(df['日時'], errors='coerce')\n        df = df.set_index('日時').sort_index()\n    else:\n        df.index = pd.to_datetime(df.index, errors='coerce')\n    df = df.loc[df.index.notna()]\n\n    # 2) 数値化\n    for c in ['気温', '風速', '蒸気圧']:\n        if c in df.columns:\n            df[c] = pd.to_numeric(df[c], errors='coerce')\n\n    # 3) 体感温度\n    df['AT'] = apparent_temperature(df.get('気温'), df.get('風速'), df.get('蒸気圧'))\n\n    # 4) 各日 06:00–18:00 に絞って日単位中央値\n    df_daytime = df.between_time('06:00', '18:00')        # 全日付対象で日中のみ抽出\n    at_daily = df_daytime['AT'].resample('D').median()     # 日ごと中央値（Series）\n    temp_daily = df_daytime['気温'].resample('D').median()     # Series\n\n    # ← ここで2列DataFrame化（列名を at_daily / temp_daily に統一）\n    daily_df = pd.concat(\n        [at_daily.rename('at_daily'), temp_daily.rename('temp_daily')],\n        axis=1\n    )\n    \n    if add_column:\n        # 元の毎時DFの各行に「その日のAT中央値」を付ける\n        df['at_daily'] = df.index.normalize().map(at_daily)\n        df['temp_daily'] = df.index.normalize().map(temp_daily)\n        return df  # 毎時データ＋列としてのAT中央値\n    else:\n        return daily_df  # 「1ヶ月分のAT日中央値」だけを返す\n\n\ndef get_Webdata(prec, block, y_start, y_end, m_start, m_end):\n    frames = []\n    for y in range(y_start, y_end+1):\n        for m in range(m_start, m_end+1):\n            days = calendar.monthrange(y, m)[1]\n            for d in range(1, days+1):\n                df = get_HourlyData(prec, block, y, m, d)\n                AT_daily = DataConversion(df, add_column=False)\n                frames.append(AT_daily)\n    AT = pd.concat(frames, axis=0, ignore_index=False)\n    display(AT)\n\n    AT.sort_index(inplace=True)\n    AT.to_csv(outdata)\n\n\npref, station = '宮城県', '仙台'\ninfo = getBlock(pref, station)\n#print(info)\nprec, block, st_name = info['prec'], info['block'], info[\"Name_2\"]\n\ny_start, y_end = 1970, 2024 \nm_start, m_end = 1, 12\n\noutdata = DATA / f\"AT_{station}_{y_start}-{y_end}.csv\"\n\nif outdata.exists():\n    print(\"from Local\")\n    AT = pd.read_csv(outdata)\nelse:\n    print(\"from Web\")\n    AT = get_Webdata(prec, block, y_start, y_end, m_start, m_end)\n\nfrom Web\n\n\n\nyear = 1993\nmonth_min, month_max = 1, 12\nREF_YEAR = 2001\nx_min, x_max =  pd.to_datetime(f\"{year}-{month_min}-01\"), pd.to_datetime(f\"{year}-{month_max}-31\")\n\ndef to_refdate(s: pd.Series) -&gt; pd.Series:\n    # 年を消して「月日だけ」を基準年に載せ替え（NaTはNaTのまま）\n    return pd.to_datetime(\n        np.where(s.notna(), s.dt.strftime(f\"{REF_YEAR}\" + \"-%m-%d\"), pd.NaT),\n        errors=\"coerce\"\n    )\ndate_ref = pd.to_datetime(AT['日時'])\nx = to_refdate(date_ref)\n\nfig, ax1 = plt.subplots(figsize=(10, 5))\nmask = date_ref.dt.year==year\nax1.plot(date_ref[mask], AT[mask]['temp_daily'], \n         linestyle='-', color=\"red\", label=f'気温[{year}]')\nax1.plot(date_ref[mask], AT[mask]['at_daily'], \n         linestyle='-', color=\"blue\", label=f'体感温度[{year}]')\nax1.set_xlim(x_min, x_max)\nax1.tick_params(axis='x', labelrotation=45)\nax1.set_ylim(-10,40)\nax1.grid()\nax1.legend()\nplt.title(f'気温・体感温度 {station} {year}')\nplt.show()\n\n\nyear = 1993\nx_min, x_max = pd.to_datetime(f\"{year}-01-01\"), pd.to_datetime(f\"{year}-12-31\")\ny_min, y_max = -15, 10\nfig, ax = plt.subplots(1,1,figsize=(10,5))\n#ax.plot(AT.index, AT['at_daily'], linestyle='none', marker='o')\n#ax.plot(AT.index, AT['temp_daily'], linestyle='none', marker='^')\n#ax.plot(AT.index, AT['at_daily'], linestyle='-', label='AT')\n#ax.plot(AT.index, AT['temp_daily'], linestyle='-', label='Temp')\n\nax.bar(AT.index, (AT['at_daily']-AT['temp_daily']), linestyle='-', label='f{year}')\nax.set_xlim(x_min, x_max)\nax.set_ylim(y_min, y_max)\nplt.title(f'「体感温度ー気温」 {station} {year}')\n#ax.legend()\nplt.savefig(OUT / f'体感温度ー気温{station}_{year}.png')\nplt.show()\n\n\nimport seaborn as sns\n\ndef make_year_calendar_heatmap(\n    df: pd.DataFrame,\n    date_col: str,\n    value_col: str,\n    drop_feb29: bool = True,\n    md_range: tuple[str, str] | None=None,\n    cmap: str = \"coolwarm\",\n    vmin: float | None=None,\n    vmax: float | None=None,\n    fig_size: tuple[float, float] = (12, 6),\n):\n    data = df[[date_col, value_col]].dropna(subset=[date_col]).copy()\n    data[date_col] = pd.to_datetime(data[date_col], errors=\"coerce\")\n    data = data.loc[data[date_col].notna()]\n\n    data[\"year\"] = data[date_col].dt.year\n    data[\"month\"] = data[date_col].dt.month\n    data[\"day\"] = data[date_col].dt.day\n\n    if drop_feb29:\n        data = data[~((data[\"month\"] == 2) & (data[\"day\"] == 29))]\n\n    REF_YEAR = 2001\n    data[\"md_ref\"] = pd.to_datetime(\n        data[date_col].dt.strftime(f\"{REF_YEAR}\" + \"-%m-%d\"), errors=\"coerce\"\n    )\n\n    # 月日範囲で抽出（同年内の範囲を想定）\n    if md_range is not None:\n        md_start = pd.to_datetime(f\"{REF_YEAR}-{md_range[0]}\")\n        md_end   = pd.to_datetime(f\"{REF_YEAR}-{md_range[1]}\")\n        data = data[(data[\"md_ref\"] &gt;= md_start) & (data[\"md_ref\"] &lt;= md_end)]\n\n    # 透視図：index=年, columns=md_ref（昇順）\n    table = (\n        data.pivot_table(index=\"year\", columns=\"md_ref\", values=value_col, aggfunc=\"mean\")\n        .sort_index(axis=1)\n        .sort_index(axis=0)\n    )\n\n    # プロット\n    plt.figure(figsize=fig_size)\n    # NaN色を調整（欠測が多い場合に灰色などに）\n\n    vmin, vmax = -10, 40\n\n    cmap_obj = mpl.colormaps.get_cmap(cmap).copy()\n    cmap_obj.set_bad(\"lightgray\")\n    mask = table.lt(vmin) | table.gt(vmax)\n\n    ax = sns.heatmap(\n        table,\n#        mask=mask,\n#        cmap=cmap_obj,\n        cmap=\"RdBu_r\",\n#        center=0,\n        vmin=vmin, vmax=vmax,  # 年比較では固定推奨\n        cbar_kws={\"label\": value_col},\n    )\n\n    # x軸：月初に目盛りを置く\n    cols = table.columns\n    # 列インデックスを必ず DatetimeIndex に揃える\n    if not isinstance(cols, pd.DatetimeIndex):\n        cols = pd.to_datetime(cols)\n        # DataFrame本体の columns も揃えておくと後続も安全\n        table.columns = cols\n\n    # 月初（MS=Month Start）を作成\n    REF_YEAR = 2001\n    months = pd.date_range(f\"{REF_YEAR}-01-01\", f\"{REF_YEAR}-12-01\", freq=\"MS\")\n    #months = pd.to_datetime([f\"{REF_YEAR}-{m:02d}-01\" for m in range(1,13)])\n\n    # DatetimeIndex.same-type で searchsorted（NumPyではなくPandasのIndexメソッド）\n    month_locs = cols.searchsorted(months)\n    # 表示範囲外を除外\n    month_locs = month_locs[month_locs &lt; len(cols)]\n\n    ax.set_xticks(month_locs)\n    # ラベル数は month_locs の長さに合わせる\n    tick_labels = [m.strftime(\"%-m/%-d\") for m in months[:len(month_locs)]]\n    ax.set_xticklabels(tick_labels, rotation=0)\n\n    ax.set_xlabel(\"Month / Day\")\n    ax.set_ylabel(\"Year\")\n    ax.set_title(f\"Calendar Heatmap: {value_col}\")\n\n    plt.tight_layout()\n    plt.show()\n\n\n# -------------------------\n# 使い方サンプル\n# -------------------------\n# 例1) 年・月・日から date を作る場合（JMA風テーブル想定）\n# df_raw に列 ['年','月','日','日平均気温'] があるとする\n# df_raw = ...\n# df_raw['date'] = pd.to_datetime(dict(year=df_raw['年'], month=df_raw['月'], day=df_raw['日']))\n# make_year_calendar_heatmap(df_raw, date_col='date', value_col='日平均気温',\n#                            drop_feb29=True, md_range=(\"06-01\",\"09-30\"),\n#                            cmap=\"coolwarm\", vmin=10, vmax=30, fig_size=(12,6))\n\n# 例2) すでに 'date' と 'value' がある場合\n#AT[\"日時\"] = AT.index\nAT['delta'] = AT['at_daily'] - AT['temp_daily']\nprint(AT)\n\n\"\"\"\nmake_year_calendar_heatmap(AT, date_col='日時', value_col='delta',\n                           drop_feb29=True, md_range=(\"06-01\",\"10-31\"),\n                           cmap=\"mako\", vmin=-5, vmax=5)\n\"\"\"\nmake_year_calendar_heatmap(AT, date_col='日時', value_col='at_daily',\n                           drop_feb29=True, md_range=(\"01-01\",\"12-31\"),\n                           cmap=\"mako\", vmin=-5, vmax=5)\n\n\n補足（実務のコツ）\n色域は固定（vmin/vmax）：年間比較の“色の意味”がぶれません（例：気温なら vmin=10, vmax=30 など）。\n\nうるう日の扱い：年比較を揃えるなら drop_feb29=True が無難。どうしても使いたい場合は 2/28 と 3/1 に分配・補間などの前処理を検討。\n\n期間抽出：md_range=(\"06-01\",\"09-30\") で夏期などに絞れます。\n\n欠測の色：cmap.set_bad(\"lightgray\") で一目で分かるように。\n\n列の粒度：日次前提。10分/1時間データなら pcolormesh（座標を渡す）を推奨。\n\n列名が決まっていれば、そのまま差し替え済み版（仙台のJMA日平均気温など）も作れます。サンプルの列名を教えてください。"
  },
  {
    "objectID": "notebooks/python/気温勾配.html",
    "href": "notebooks/python/気温勾配.html",
    "title": "",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n\nfrom meteo_lib import PROJECT  # または: from meteo_lib.paths import PROJECT\n#out_dir  = PROJECT / \"outputs\"\n\nfrom meteo_lib.meteo_lib import getBlock, get_HourlyData, get_10minData\nfrom meteo_lib.my_path_utils import DATA, OUT\n\nimport pandas as pd\nimport math\nimport numpy as np\nfrom datetime import datetime, timedelta, date, time\nfrom metpy.units import units\nfrom metpy.calc import dewpoint_from_relative_humidity\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.rcParams[\"font.family\"] = \"IPAexGothic\"   # 例：Noto Sans CJK JP でも可\nmpl.rcParams[\"axes.unicode_minus\"] = False    # －が豆腐になるのを回避\n\nimport matplotlib.dates as mdates\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.ticker import FuncFormatter, MultipleLocator\nimport os\nfrom pathlib import Path\nimport calendar\nfrom IPython.display import display \n\n\ndef get_Webdata(prec, block, y_start, y_end, m_start, m_end, outdata, use_Flag):\n    print(use_Flag)\n    dfs = []\n    for y in range(y_start, y_end+1):\n        for m in range(m_start, m_end+1):\n            days = calendar.monthrange(y, m)[1]\n            for d in range(1, days+1):\n                df_daily = get_HourlyData(prec, block, y, m, d)\n                dfs.append(df_daily)\n        print(y)\n    df = pd.concat(dfs, axis=0, ignore_index=False)\n    display(df)\n\n    df.sort_index(inplace=True)\n    df.to_csv(outdata)\n    return df\n\n\ndtype_map = {\n    '現地気圧': 'float32',\n    '海面気圧': 'float32',\n    '降水量': 'float32',\n    '気温': 'float32',\n    '露点温度': 'float32',\n    '蒸気圧': 'float32',\n    '湿度': 'float32',\n    '風速': 'float32',\n    '風向': 'string',\n    '日照': 'float32',\n    '全天日射量': 'float32',\n    '降雪': 'float32',\n    '積雪': 'float32',\n    '天気': 'string',\n    '雲量': 'string',\n    '視程': 'float32'\n}\npref, station = '秋田県', '秋田'\ninfo = getBlock(pref, station)\nprec, block, st_name = info['prec'], info['block'], info[\"Name_2\"]\n\ny_start, y_end = 1961,2024\nm_start, m_end = 1, 12\n\nindata = DATA / f\"Hourly_{station}_{y_start}-{y_end}.csv\"\nprint(indata)\n\nif indata.exists():\n    print(\"from Local\")\n    df = pd.read_csv(\n        indata,\n        dtype=dtype_map,\n        encoding='utf-8')\nelse:\n    print(\"from Web\")\n    df = get_Webdata(prec, block, y_start, y_end, m_start, m_end, indata, True)\n\nflag_cols = df.filter(regex=r'_flag$').columns.tolist()\nprint(flag_cols)\ndf = df.drop(columns=flag_cols, errors='ignore')\n\ndf['日時'] = pd.to_datetime(df['日時'])\nprint(df.dtypes)\ndf\n\n/Users/takumi/Library/Mobile Documents/com~apple~CloudDocs/Projects/JMA-data/data/Hourly_秋田_1961-2024.csv\nfrom Web\nTrue\n1961\n1962\n1963\n1964\n1965\n1966\n1967\n1968\n1969\n1970\n1971\n1972\n1973\n1974\n1975\n1976\n1977\n1978\n1979\n1980\n1981\n1982\n1983\n1984\n1985\n1986\n1987\n1988\n1989\n1990\n1991\n1992\n1993\n1994\n1995\n1996\n1997\n1998\n1999\n2000\n2001\n2002\n2003\n2004\n2005\n2006\n2007\n2008\n2009\n2010\n2011\n2012\n2013\n2014\n2015\n2016\n2017\n2018\n2019\n2020\n2021\n2022\n2023\n2024\n\n\n\n\n\n\n\n\n\n現地気圧\n海面気圧\n降水量\n気温\n露点温度\n蒸気圧\n湿度\n風速\n風向\n日照\n...\n天気\n雲量\n視程\n風速_flag\n降水量_flag\n全天日射量_flag\n露点温度_flag\n蒸気圧_flag\n日照_flag\n気温_flag\n\n\n日時\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1961-01-01 01:00:00\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\nNaN\nNaN\n\nNaN\n...\n\n\nNaN\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n1961-01-01 02:00:00\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\nNaN\nNaN\n\nNaN\n...\n\n\nNaN\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n1961-01-01 03:00:00\n1006.000000\n1007.200012\n0.0\n-2.1\nNaN\n4.9\n94.0\n2.0\n北\nNaN\n...\n\n10\nNaN\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n1961-01-01 04:00:00\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\nNaN\nNaN\n\nNaN\n...\n\n\nNaN\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n1961-01-01 05:00:00\nNaN\nNaN\n0.0\nNaN\nNaN\nNaN\nNaN\nNaN\n\nNaN\n...\n\n\nNaN\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n2024-12-31 20:00:00\n1003.500000\n1006.200012\n2.5\n1.3\n-0.1\n6.0\n90.0\n7.4\n北北西\nNaN\n...\nみぞれ\n\n2.34\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n2024-12-31 21:00:00\n1004.299988\n1007.000000\n2.0\n1.4\n0.3\n6.2\n92.0\n6.8\n北北西\nNaN\n...\nみぞれ\n\n7.18\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n2024-12-31 22:00:00\n1004.700012\n1007.400024\n1.0\n1.0\n0.0\n6.1\n93.0\n4.4\n北\nNaN\n...\nみぞれ\n\n20.00\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n2024-12-31 23:00:00\n1005.400024\n1008.099976\n0.0\n3.1\n-1.4\n5.5\n72.0\n5.5\n北西\nNaN\n...\nみぞれ\n\n20.00\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n2025-01-01 00:00:00\n1005.799988\n1008.500000\n0.0\n3.1\n-2.2\n5.2\n68.0\n8.6\n北西\nNaN\n...\n曇\n\n20.00\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n\n\n561024 rows × 23 columns\n\n\n\n['風速_flag', '降水量_flag', '全天日射量_flag', '露点温度_flag', '蒸気圧_flag', '日照_flag', '気温_flag']\n\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/miniforge3/envs/py312/lib/python3.12/site-packages/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n   3811 try:\n-&gt; 3812     return self._engine.get_loc(casted_key)\n   3813 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7088, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7096, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: '日時'\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[29], line 43\n     40 print(flag_cols)\n     41 df = df.drop(columns=flag_cols, errors='ignore')\n---&gt; 43 df['日時'] = pd.to_datetime(df['日時'])\n     44 print(df.dtypes)\n     45 df\n\nFile ~/miniforge3/envs/py312/lib/python3.12/site-packages/pandas/core/frame.py:4107, in DataFrame.__getitem__(self, key)\n   4105 if self.columns.nlevels &gt; 1:\n   4106     return self._getitem_multilevel(key)\n-&gt; 4107 indexer = self.columns.get_loc(key)\n   4108 if is_integer(indexer):\n   4109     indexer = [indexer]\n\nFile ~/miniforge3/envs/py312/lib/python3.12/site-packages/pandas/core/indexes/base.py:3819, in Index.get_loc(self, key)\n   3814     if isinstance(casted_key, slice) or (\n   3815         isinstance(casted_key, abc.Iterable)\n   3816         and any(isinstance(x, slice) for x in casted_key)\n   3817     ):\n   3818         raise InvalidIndexError(key)\n-&gt; 3819     raise KeyError(key) from err\n   3820 except TypeError:\n   3821     # If we have a listlike key, _check_indexing_error will raise\n   3822     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3823     #  the TypeError.\n   3824     self._check_indexing_error(key)\n\nKeyError: '日時'\n\n\n\n\n#df['日時'] = pd.to_datetime(df['日時'], errors='coerce')  # まず確実にdatetime化\ndf = df.set_index('日時').sort_index()\n\nout_month = (\n    df.groupby([pd.Grouper(freq='ME')])['気温']\n      .agg(['mean', 'max', 'min', 'median', 'count'])\n)\nprint(out_month)\n\n\ndef monthly_climatology_mom(\n    df, dt_col='日時', value_col='mean', *,\n    start_year, end_year, wrap=False\n):\n    x = df.copy()\n    x[dt_col] = pd.to_datetime(x[dt_col])\n\n    # 1) 期間を切る\n    m = (x.loc[x[dt_col].dt.year.between(start_year, end_year)]\n           .resample('ME', on=dt_col)[value_col]        # 月末基準で月平均\n           .mean()\n           .to_frame('月平均'))\n\n    # 2) 月番号で平年化（12値）\n    m['月'] = m.index.month\n    clim = (m.groupby('月')['月平均']\n              .mean()\n              .rename('基準月平均')           # 1991–2020の“平年”月平均\n              .to_frame())\n\n    # 3) 前月差（Jan は NaN。wrap=True なら Dec→Jan の差も計算）\n    clim['前月差'] = clim['基準月平均'].diff()\n    if wrap:\n        # 12月→1月も含めた循環差\n        prev = clim['基準月平均'].shift(1)\n        prev.iloc[0] = clim['基準月平均'].iloc[-1]\n        clim['前月差_cyclic'] = clim['基準月平均'] - prev\n\n    clim = clim.reset_index()  # 列: 月, 基準月平均, 前月差(, 前月差_cyclic)\n    return clim\n\n# 使い方\ndiff_month = pd.DataFrame(index=range(1,13))\nout_month['日時'] = out_month.index\n#print(out_month)\nys = 1961\nye = 1991\n#diff_month = []\nfor y in range(ys, ye+1, 10):\n    clim_df = monthly_climatology_mom(out_month, dt_col='日時', \n          value_col='mean', start_year=y, end_year=y+11, wrap=True)\n    if isinstance(clim_df, list) or isinstance(clim_df, tuple):\n        clime_df = clim_df[0]\n        \n#    colname = f'{y}_diff_month'\n    colname = f'{y}_{y+29}'\n    s = clim_df.set_index('月')['前月差']\n#    print('out_type: ',type(out))\n    diff_month[colname] = s.reindex(diff_month.index).to_numpy()\n#    print(y, out)\n\ndiff_month\n\n\nfig, ax = plt.subplots(figsize=(10,7))\nfor y in  range(ys, ye+1, 10):\n    colname = f'{y}_{y+29}'\n    ax.bar(diff_month.index, diff_month[colname], label=y)\nax.set_xlim(8, 11)\nax.legend()\nplt.show()\n\n\nimport matplotlib.pyplot as plt\nmpl.rcParams[\"font.family\"] = \"IPAexGothic\"   # 例：Noto Sans CJK JP でも可\nmpl.rcParams[\"axes.unicode_minus\"] = False    # －が豆腐になるのを回避\n\ncols = [f\"{y}_{y+29}\" for y in range(ys, ye+1, 10) \n        if f\"{y}_{y+29}\" in diff_month.columns]\n\nax = diff_month.loc[8:11, cols].plot(\n    kind='bar', figsize=(10,7), rot=0)  # ← 横並びがデフォルト\nax.set_xlabel('月', fontsize=14)\nax.set_ylabel('前月差（℃）', fontsize=14)\n# 目盛ラベルのフォントサイズ\nax.tick_params(axis='x', labelsize=14)\nax.tick_params(axis='y', labelsize=14)\n\nax.legend(title='平年値')\nax.axhline(0, linewidth=1)\nplt.title(f'前月との差（平均気温、{station}）', fontsize=16)\nplt.tight_layout()\nplt.savefig(OUT / f'前月差_平均気温_平年値_{station}.png')\nplt.show()"
  },
  {
    "objectID": "notebooks/python/plot_20250326_仙台他.html",
    "href": "notebooks/python/plot_20250326_仙台他.html",
    "title": "",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n\nfrom meteo_lib import PROJECT  # または: from meteo_lib.paths import PROJECT\n#out_dir  = PROJECT / \"outputs\"\n\nfrom meteo_lib.meteo_lib import getBlock, get_HourlyData, get_10minData\nfrom meteo_lib.my_path_utils import DATA, OUT\n\n\nimport pandas as pd\nimport math\nimport numpy as np\nfrom datetime import datetime, timedelta, date, time\nfrom metpy.units import units\nfrom metpy.calc import dewpoint_from_relative_humidity\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.dates as mdates\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.ticker import FuncFormatter, MultipleLocator\nimport os\nfrom pathlib import Path\n\n\n# 風向を、float配列に変換する\ndef ary_int_dd(ary):\n    dic = {'北':16,'北北東':1,'北東':2,'東北東':3,\n           '東':4,'東南東':5,'南東':6,'南南東':7,\n           '南':8,'南南西':9,'南西':10,'西南西':11,\n           '西':12,'西北西':13,'北西':14,'北北西':15, '静穏':np.nan}\n    awd = np.empty(len(ary),dtype=float)\n    for ind in range(len(ary)):\n        val = ary.iloc[ind].replace(' )','')\n        if val in dic:\n            awd[ind] = dic[val]\n        else:\n            awd[ind] = np.nan\n    return awd\n\ndef DataConversion(df):\n\n    ns = df.shape[1]\n    df['平均風向_dir'] = ary_int_dd(df['平均風向']) * 22.5\n    df['最大瞬間時風向_dir'] = ary_int_dd(df['最大瞬間時風向']) * 22.5\n\n    if ns &gt; 7:\n        TT = df['気温'].values * units.degC   # 気温\n        RH = df['相対湿度'].values * units.percent    # 相対湿度\n        Td = dewpoint_from_relative_humidity(TT, RH).to('degC')\n        df['露点'] = Td.magnitude\n\n    return df\n\n\n# 追加：方位 → 角度 の辞書\nDIR_TO_DEG = {\n    'N': 360, 'NNE': 22.5, 'NE': 45, 'ENE': 67.5, 'E':  90,\n    'ESE': 112.5, 'SE': 135, 'SSE': 157.5, 'S': 180,\n    'SSE': 202.5, 'SW': 225, 'WSW': 247.5, 'W':  270,\n    'WNW':292.5, 'NW': 315, 'NNW': 337.5\n}\n\ndef range_from_dirs(start_dir: str, end_dir: str):\n    \"\"\"方位文字列から角度範囲を生成\"\"\"\n    if start_dir not in DIR_TO_DEG or end_dir not in DIR_TO_DEG:\n        raise ValueError(f\"Invalid direction: {start_dir}, {end_dir}\")\n    start = DIR_TO_DEG[start_dir]\n    end   = DIR_TO_DEG[end_dir]\n\n    # 例えば N→E なら (0, 90)、S→NW なら (180, 315)\n    if start &lt;= end:\n        return (start, end)\n    else:\n        # 例: NW → NE (315 → 45) → wrap する場合は360度またぐ\n        return (start, end + 360)\n\n\n# ===== パラメータ =====\nFONTSIZE = 14\nROW_HEIGHT = 3  # ★ 1段あたりの高さを固定（ここを変えると全体バランスが変わる）\n\n# ===== 16方位ラベル =====\ndirs16 = ['N','NNE','NE','ENE','E','ESE','SE','SSE',\n          'S','SSW','SW','WSW','W','WNW','NW','NNW']\n\ndef dir_formatter(y, pos):\n    val = y % 360\n    i = int((val / 22.5) + 0.5) % 16\n    return f'{dirs16[i]} '\n\n\"\"\"\ndef dir_formatter(deg, pos):\n    d = deg % 360\n\n    # 0°ラベルは消す\n    if np.isclose(d, 0.0, atol=1e-6) and deg &lt; 360:\n        return ''\n\n    # 360°は N を表示したい\n    if np.isclose(deg, 360.0, atol=1e-6):\n        return 'N'\n\n    # 通常の方位ラベル\n    idx = int(((d / 22.5) + 0.5)) % 16\n    return dirs16[idx]\n\"\"\"\n\ndef _first_col(df: pd.DataFrame, candidates: list[str]) -&gt; str | None:\n    for c in candidates:\n        if c in df.columns:\n            return c\n    return None\n\n\ndef _unwrap_per_runs(deg_series: pd.Series) -&gt; pd.Series:\n    \"\"\"NaNで分断された連続区間ごとに unwrap する（度→度）。\n    入力: 度（0-360想定, NaN含む可）\"\"\"\n    vals = pd.to_numeric(deg_series, errors='coerce').mod(360).to_numpy(float)\n    mask = np.isfinite(vals)\n    out = np.full_like(vals, np.nan, dtype=float)\n\n    # NaNの場所で区切るためのランID\n    # True/False -&gt; Falseの累積和で「穴」の数を数える\n    run_id = (~mask).cumsum()\n\n    # 連続 True 区間ごとに unwrap\n    if mask.any():\n        for gid in np.unique(run_id[mask]):\n            idx = (mask & (run_id == gid))\n            rad_seg = np.deg2rad(vals[idx])\n            out[idx] = np.rad2deg(np.unwrap(rad_seg))\n    return pd.Series(out, index=deg_series.index, dtype=float)\n\ndef prepare_wind(df: pd.DataFrame, sel: str) -&gt; pd.DataFrame:\n\n#    sel='JMA'    : 平均風向 + (あれば) 最大瞬間風向 を unwrap。表示列(_disp_*)も付与。\n#    sel!='JMA'   : 平均風向のみ unwrap。ガスト系は一切作らない。\n\n    df = df.copy()\n\n    # --- 平均風向の列名（両者で共通に探す） ---\n    col_avg = _first_col(df, [\"平均風向_dir\", \"風向_dir\", \"風向(度)\", \"風向\"])\n    if col_avg is None:\n        raise KeyError(\"平均風向の列が見つかりません（例: '平均風向_dir'）。\")\n\n    # 平均風向 unwrap\n    df[\"wind_unwrap\"] = _unwrap_per_runs(df[col_avg])\n    df[\"_disp_avg\"]   = np.mod(df[\"wind_unwrap\"], 360.0)\n\n    if sel == \"JMA\":\n        # JMA のみ “最大瞬間風向” を探す（無ければスキップ）\n        col_gust_dir = _first_col(df, [\"最大瞬間時風向_dir\", \"最大瞬間風向_dir\", \"最大風速風向_dir\"])\n        if col_gust_dir is not None:\n            df[\"wind_max_unwrap\"] = _unwrap_per_runs(pd.to_numeric(df[col_gust_dir], errors=\"coerce\"))\n            base = df[\"wind_unwrap\"].to_numpy(float)\n            cand = df[\"wind_max_unwrap\"].to_numpy(float)\n            with np.errstate(invalid=\"ignore\"):\n                aligned = cand + 360.0 * np.round((base - cand) / 360.0)\n            df[\"wind_max_unwrap_aligned\"] = aligned\n            df[\"_disp_max\"] = np.mod(df[\"wind_max_unwrap_aligned\"], 360.0)\n        # gust 列が無ければ何もしない（列自体を作らない）\n    # sel!='JMA' は何もしない（平均のみ）\n\n    return df\n\n\ndef style_axis(ax, ylabel=None, fontsize=FONTSIZE, hide_xlabels=False):\n    ax.tick_params(axis='both', labelsize=fontsize)\n    if ylabel:\n        ax.set_ylabel(ylabel, fontsize=fontsize)\n    if hide_xlabels:\n        ax.tick_params(labelbottom=False)\n    ax.grid(True, which='both', axis='both', alpha=0.3)\n\n\ndef set_shared_time_axis_all(axes, start, end, fmt='%H:%M', label_interval=2,\n                             grid_interval=1, fontsize=FONTSIZE):\n\n#    複数サブプロットの x 軸を完全共通化。\n#    - 目盛位置/フォーマッタ/表示範囲は sharex の“親軸”へ一度だけ設定\n#    - グリッドとラベルサイズは各軸に適用\n\n    import matplotlib.dates as mdates\n\n    master = axes[-1]  # 一番下を親に（ラベルを表示する軸）\n    # --- 共有対象（limits/locators/formatter は sharex で全軸に伝播） ---\n    master.set_xlim(start, end)\n    master.xaxis.set_major_locator(mdates.HourLocator(interval=label_interval))\n    master.xaxis.set_minor_locator(mdates.HourLocator(interval=grid_interval))\n    master.xaxis.set_major_formatter(mdates.DateFormatter(fmt))\n\n    # --- 見た目（グリッド/ラベル）は各軸で ---\n    for ax in axes:\n        # xグリッド（共通のメジャー/マイナーに合わせて描く）\n        ax.grid(True, which='major', axis='x', linestyle='-',  linewidth=1.3, alpha=1.0)\n        ax.grid(True, which='minor', axis='x', linestyle='--', linewidth=0.8, alpha=0.8)\n        # xラベルは親だけ表示\n        is_master = (ax is master)\n        ax.tick_params(axis='x', labelsize=fontsize, labelbottom=is_master)\n\ndef plot_wind_direction(ax, df, sel, fold_to_360=True,\n                       dir_range: tuple[str, str] | None=None):\n\n#    dir_range: ('N', 'SE')などの指定があればそれを優先してylimに反映\n\n    df = df[df.index.notna()].copy()\n\n    # 0° を 360° に統一するヘルパ\n    def north_to_360(s, tol=1e-3):\n#    風向角 s（Series または配列）を 0〜360 に正規化し、\n#    0° 付近（±tol）は 360° に寄せる。\n\n        if s is None:\n            return None\n        # 数値化してコピー\n        s = pd.to_numeric(s, errors='coerce').astype(float).copy()\n        # 一応 360 の倍数は全部 360 にそろえる\n        s = np.mod(s, 360.0)   # 0, 360, 720 ... → 0\n#        s[s == 0.0] = 360.0    # 0 → 360 に統一\n        # 0° 付近（例えば ±0.001°）を 360° にまとめる\n        s[np.isclose(s, 0.0, atol=tol)] = 360.0\n        \n        return s\n\n    if fold_to_360:\n#        y_avg = df[\"_disp_avg\"]\n#        y_max = df[\"_disp_max\"] if \"_disp_max\" in df.columns else None\n        y_avg = north_to_360(df[\"_disp_avg\"])\n        y_max = north_to_360(df[\"_disp_max\"] if \"_disp_max\" in df.columns else None)\n        \n        if dir_range is None:\n            # 従来どおり 0〜360 を少しはみ出して表示\n            ylim = (-10, 370)\n        else:\n            # 方位指定に基づいて上書き\n            ylim = range_from_dirs(*dir_range)\n    else:\n        y_avg = df[\"wind_unwrap\"]\n        y_max = df[\"wind_max_unwrap_aligned\"] if \"wind_max_unwrap_aligned\" in df.columns else None\n\n        if dir_range is None: # 指定が無ければ元の計算\n            yall = pd.concat([y_avg, y_max]) if y_max is not None else y_avg\n            yall = pd.to_numeric(yall, errors='coerce')\n            yall = yall[np.isfinite(yall)]\n            if len(yall):\n                pad = 15.0\n                y0 = np.floor((yall.min() - pad) / 22.5) * 22.5\n                y1 = np.ceil((yall.max() + pad) / 22.5) * 22.5\n                ylim = (y0, y1)\n            else:\n                ylim = (0, 360)\n        else:\n            # --- ⬇️ 方位指定に基づく ylim 上書き ---\n            ylim_deg = range_from_dirs(*dir_range)\n            ylim = ylim_deg\n\n    ax.yaxis.set_major_locator(MultipleLocator(45))\n    ax.yaxis.set_minor_locator(MultipleLocator(22.5))\n    ax.yaxis.set_major_formatter(FuncFormatter(dir_formatter))\n\n    if sel=='JMA':\n        lb='Avg'\n    else:\n        lb=''\n    h = []\n    h += ax.plot(df.index, y_avg, linestyle='None', marker='o', \n                 markersize=4, label=f'{lb} Wind Dir')\n    if y_max is not None:\n        h += ax.plot(df.index, y_max, linestyle='None', color='red',\n                     marker='+', markersize=5, label='Max Wind Dir')\n\n    ax.set_ylim(*ylim)\n    ax.set_ylabel(\"Wind direction (°)\")\n\n    # 実体がある線だけで凡例\n    handles, labels = ax.get_legend_handles_labels()\n    non_empty = []\n    non_labels = []\n    for hd, lb in zip(handles, labels):\n        ydata = getattr(hd, \"get_ydata\", lambda: np.array([]))()\n        if np.isfinite(np.asarray(ydata)).any():\n            non_empty.append(hd)\n            non_labels.append(lb)\n    if non_empty:\n        ax.legend(non_empty, non_labels)\n\n    ax.grid(True, which='both', axis='y', linestyle='--')\n\n\ndef plot_wind_speed(ax, df, sel, ws_range):\n    ws_min, ws_max = ws_range\n    ax.set_ylim(ws_min, ws_max)\n    if sel=='JMA':\n        lb = 'Avg Wind Speed'\n    else:\n        lb = 'Wind Speed'\n    ax.plot(df.index, pd.to_numeric(df['平均風速'], errors='coerce'),\n            linestyle='None', marker='o', markersize=4, label=lb)\n    if sel == 'JMA' and '最大瞬間風速' in df.columns:\n        ax.plot(df.index, pd.to_numeric(df['最大瞬間風速'], errors='coerce'),\n                linestyle='None', marker='+', markersize=5, color='red', label='Max Wind Speed')\n    ax.legend()\n    \n\ndef plot_temperature(ax, df, sel, include_dewpoint, select_dew, Temp_range):\n\n    if sel=='JMA':\n#        Temp_min, Temp_max = 0, 25    \n        Temp_min, Temp_max = Temp_range\n        RH_min, RH_max = 30, 100\n    else:\n        Temp_min, Temp_max = 7.5, 20\n        RH_min, RH_max = 30, 100\n    \n    ax.set_ylim(Temp_min, Temp_max)\n    ax.plot(df.index, pd.to_numeric(df['気温'], errors='coerce'), \n            linestyle='None', marker='^', markersize=4,\n            color='green', label='Temperature')\n    if include_dewpoint and '露点' in df.columns:\n        if select_dew==True:\n            ax.plot(df.index, pd.to_numeric(df['露点'], errors='coerce'),\n                    linestyle='None', marker='v', markersize=4, color='orange',\n                    label='Dew Point')\n        else:\n            ax_RH = ax.twinx()\n            ax_RH.plot(df.index, pd.to_numeric(df['相対湿度'], errors='coerce'),\n                    linestyle='None', marker='*', markersize=4, color='skyblue',\n                    label='Relative Humidity')\n            ax_RH.set_ylim(RH_min, RH_max)\n            ax_RH.set_ylabel('Relative Humidity (%)', fontsize=FONTSIZE)\n            ax_RH.tick_params(axis='y', labelsize=FONTSIZE)  # 目盛ラベルも揃える\n\n    # --- ここで左右のハンドルを結合し、重複ラベルを除去して一つの凡例に ---\n        if select_dew==False:\n            handles, labels = ax.get_legend_handles_labels()\n            if ax_RH is not None:\n                h2, l2 = ax_RH.get_legend_handles_labels()\n                handles += h2\n                labels  += l2\n\n        # ラベル重複を除去（同名ラベルは後勝ち）\n            by_label = dict(zip(labels, handles))\n\n        # 外出しで重なり回避\n            ax.legend(by_label.values(), by_label.keys(),\n                      loc='upper right')\n\n            return ax_RH  # 必要なら呼び出し側で使えるように返す\n        else:\n            ax.legend()\n    \ndef plot_pressure(ax, df, sel, Press_range):\n\n    if sel=='JMA':\n        P_min, P_max = Press_range\n#        P_min, P_max = 990, 1031\n    else:\n        P_min, P_max = 952, 968.1\n    ax.set_ylim(P_min, P_max)\n    ax.set_yticks(np.arange(P_min, P_max, 5))\n    ax.yaxis.set_major_locator(MultipleLocator(1))\n    ax.plot(df.index, pd.to_numeric(df['気圧'], errors='coerce'),\n            linestyle='None', marker='D', markersize=3, \n            color='purple', label='Local Pressure')\n    ax.legend()\n\ndef plot_station(df, station_name, sel, \n                 include_pressure=False, \n                 include_dewpoint=False,\n                 select_dew=False,\n                 start=None, end=None, savepath=None, \n                 dir_range=None, WS_range=None, Temp_range=None,\n                 Press_range=None, title_date_text=None):\n\n    # --- start / end を後で指定する形にする ---\n    if start is None:\n        start = df.index.min()  # あるいはユーザー指定\n    if end is None:\n        end = df.index.max()\n\n    # --- 日付表記の自動処理 ---\n    if title_date_text is None:\n        # index から自動生成（※ 1点だけなら日付取得可）\n        try:\n            dt = pd.to_datetime(df.index[0])\n            title_date_text = dt.strftime('%Y.%m.%d')\n        except:\n            title_date_text = ''\n\n    df = prepare_wind(df, sel)   # ← ここだけで JMA/非JMA の差を吸収\n\n    nrows = 4 if include_pressure else 3\n    fig, axes = plt.subplots(\n        nrows, 1, figsize=(12, ROW_HEIGHT * nrows),\n        tight_layout=True, gridspec_kw={'height_ratios': [1]*nrows}, sharex=True\n    )\n    if nrows == 1:\n        axes = [axes]\n    ax_dir, ax_wind, ax_temp = axes[0], axes[1], axes[2]\n\n    plot_wind_direction(ax_dir, df, sel, fold_to_360=True, \n                        dir_range=dir_range)\n    style_axis(ax_dir, ylabel='Wind Direction', hide_xlabels=True)\n\n    plot_wind_speed(ax_wind, df, sel, ws_range=WS_range)\n    style_axis(ax_wind, ylabel='Wind Speed (m/s)', hide_xlabels=True)\n\n    plot_temperature(ax_temp, df, sel, \n                     include_dewpoint=include_dewpoint,\n                     select_dew=select_dew, Temp_range=Temp_range)\n    style_axis(ax_temp, ylabel='Temperature (℃)', hide_xlabels=include_pressure)        \n\n    if include_pressure:\n        ax_pres = axes[3]\n        plot_pressure(ax_pres, df, sel, Press_range=Press_range)\n        style_axis(ax_pres, ylabel='Pressure (hPa)')\n\n    set_shared_time_axis_all(axes, start, end, fmt='%H:%M', \n                             label_interval=1, grid_interval=1)    # x軸ラベル間隔\n    fig.suptitle(f'{station_name} / {title_date_text}', fontsize=FONTSIZE+2)\n    plt.tight_layout(rect=[0, 0.03, 1, 0.99])\n    if savepath:\n        plt.savefig(savepath)\n    plt.show()\n\n\n# ===== データ取得 =====\nsel = 'JMA'\n#sel = 'Tohoku'    # 'JMA' or 'Tohoku Univ'\n\nif sel=='JMA':\n    year, month, day = 2025, 2, 26    # 対象年月日\n    start_hour, end_hour = 6, 21    # 描画範囲（時間指定）\n    pref, station = '宮城県', '名取'\n    info = getBlock(pref, station)\n    print(info)\n    prec, block, st_name = info['prec'], info['block'], info[\"Name_2\"]\n\n    df = get_10minData(prec, block, year, month, day)\n    df = DataConversion(df)\nelse:\n    year, month, day = 2025, 3, 26    # 日時固定\n    start_hour, end_hour = 6, 18     # 描画範囲（時間指定）\n    fn2 = DATA / \"遠刈田中学校AWS-20250326.csv\"\n    data2 = pd.read_csv(fn2, usecols=[1, 2, 3, 4, 5, 6], skiprows=1, \n                    names=['日時', '気温', '相対湿度', '気圧', '平均風速', '平均風向_dir'],\n                    dtype={'気温':'float32', '相対湿度':'float32',\n                           '気圧':'float32', '平均風速':'float32', '平均風向_dir':'float32'},\n                    encoding='cp932')\n    data2['日時'] = pd.to_datetime(data2['日時'])\n    df = data2\n    df = df.set_index('日時')\n    TT = df['気温'].values * units.degC   # 気温\n    RH = df['相対湿度'].values * units.percent    # 相対湿度\n    Td = dewpoint_from_relative_humidity(TT, RH).to('degC')\n    df['露点'] = Td.magnitude\n    st_name = 'Togatta JHS'\n\noutdata = DATA / f\"{st_name}_{year}{month:02d}{day:02d}.csv\"\noutfig = OUT / f\"plot250326/{st_name}_{year}{month:02d}{day:02d}.png\"\n\ndf.sort_index(inplace=True)\ndf.to_csv(outdata, encoding='shift-jis')\n\n# ===== 作図 =====\n# X軸の表示範囲\nstart = pd.Timestamp(f\"{year}-{month}-{day} {start_hour}:00\")\nend   = pd.Timestamp(f\"{year}-{month}-{day} {end_hour}:00\")\nprint(start, '  ', end)\n\n{'prec': 34, 'block': 1464, 'Name_2': 'NATORI', 'Alt': 2.0, 'H_Anemo': 8.2, 'Lat': 38.138, 'Lon': 140.917}\n2025-02-26 06:00:00    2025-02-26 21:00:00\n\n\n\n# まず、ケースごとにパラメータを決める\ndir_range = None    # 全方位\ndir_range = ('S', 'NNE')    # 方位表示範囲\nWS_range = (0, 20)    # 風速表示範囲\nTemp_range = (0, 15)    # 気温表示範囲\nPress_range = (1006,1010)    # 気圧表示範囲\n\nif sel == 'JMA':\n    station_label = st_name\n    if block &gt; 40000:\n        include_pressure  = True\n        include_dewpoint  = True\n    else:\n        include_pressure  = False    # 常にFalse\n        include_dewpoint  = False\nelse:\n    station_label     = 'Togatta JHS [Tohoku Univ.]'\n    include_pressure  = True\n    include_dewpoint  = True\n# include_dewpoint がTrueで露点または相対湿度を表示、Falseでどちらも非表示\n\n# 決まったパラメータを使って 1 回だけ呼ぶ\nplot_station(\n    df.copy(), station_label, sel,\n    include_pressure=include_pressure,\n    include_dewpoint=include_dewpoint,\n    select_dew=True,    \n    # select_dew がTrueで露点、Falseで相対湿度を表示(include_dewpoint=Trueの場合) \n    start=start, end=end,\n    dir_range=dir_range,\n    WS_range=WS_range,\n    Temp_range=Temp_range,\n    Press_range=Press_range,\n    savepath=outfig,\n)"
  },
  {
    "objectID": "notebooks/python/春・秋の長さ.html",
    "href": "notebooks/python/春・秋の長さ.html",
    "title": "",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n\nfrom meteo_lib import PROJECT  # または: from meteo_lib.paths import PROJECT\nfrom meteo_lib.my_path_utils import DATA, OUT\n\nimport meteo_lib.meteo_lib as ml\nfrom meteo_lib.my_path_utils import DATA, OUT\n\nimport pandas as pd\nimport numpy as np\nfrom pathlib import Path\nfrom typing import Any, Optional, Tuple\nfrom functools import lru_cache\nimport time\nimport matplotlib.pyplot as plt\n#import japanize_matplotlib\nfrom matplotlib.dates import DateFormatter\nimport datetime as dt\nimport matplotlib.dates as mdates\n\nimport matplotlib as mpl\n\nmpl.rcParams[\"font.family\"] = \"IPAexGothic\"   # 例：Noto Sans CJK JP でも可\nmpl.rcParams[\"axes.unicode_minus\"] = False    # －が豆腐になるのを回避\n# 保存時の文字化け対策（必要なら）\nmpl.rcParams[\"pdf.fonttype\"] = 42\nmpl.rcParams[\"ps.fonttype\"]  = 42\n\n\n# 複数年のJMAデータを取得してひとつのDataFrameにまとめる\ndef make_multi_year_daily_tables_jma(\n    *,\n    prec: int,\n    block: int,\n    start_year: int,\n    end_year: int,\n    months = range(1, 13),\n    day: int = 1,                 # JMAの「日別」は月表を返すので 1 固定でOK（関数シグネチャに合わせて渡す）\n    sleep_sec: float = 0.8,       # 取得間隔（マナー＆弾かれ防止）\n    max_retries: int = 3,         # 月単位取得のリトライ回数\n    drop_feb29: bool = True,      # うるう日を揃えたい場合は True\n#    out_dir: str = \"out_csv\",\n    prefix: str = \"daily\"\n) -&gt; dict[str, pd.DataFrame]:\n\n    Path(OUT).mkdir(parents=True, exist_ok=True)\n\n    frames = []\n    value_cols = ['平均気温', '最高気温', '最低気温']\n\n    for year in range(start_year, end_year + 1):\n        for month in months:\n            last_err = None\n            for trial in range(1, max_retries + 1):\n                try:\n                    df_m = ml.getDailyData(prec, block, year, month, day)\n                    df_m = df_m.reset_index(names='日時')\n                    print(df_m)\n\n                    # 必須列チェック\n#                    needed = ['年月日'] + value_cols\n                    needed = ['日時'] + value_cols\n                    missing = [c for c in needed if c not in df_m.columns]\n                    if missing:\n                        raise ValueError(f\"get_DailyDataの戻り値に欠落列: {missing}\")\n\n                    # 型そろえ\n                    df_m = df_m[['日時'] + value_cols].copy()\n                    df_m['日時'] = pd.to_datetime(df_m['日時'], errors='coerce')\n                    for c in value_cols:\n                        df_m[c] = pd.to_numeric(df_m[c], errors='coerce')\n\n                    frames.append(df_m)\n                    break  # 成功\n                except Exception as e:\n                    last_err = e\n                    if trial &lt; max_retries:\n                        time.sleep(sleep_sec)\n                        continue\n                    # リトライ尽きた\n                    raise RuntimeError(f\"JMA取得失敗: year={year}, month={month} ({e})\") from e\n            time.sleep(sleep_sec)  # 次の月へ\n\n    # 全結合と整形\n    df = pd.concat(frames, ignore_index=True)\n    df = df.dropna(subset=['日時'])               # 日付欠損は除外\n    df = df.sort_values('日時')\n    df = df[~df['日時'].duplicated(keep='first')]\n\n    if drop_feb29:\n        md = df['日時']\n        df = df[~((md.dt.month == 2) & (md.dt.day == 29))]\n\n    # インデックス化（以降の処理が楽）\n    df = df.set_index('日時')\n\n    # datetime列を残したまま保存\n    df_out = df[value_cols].copy()\n    df_out.insert(0, '日時', df.index)  # indexを列に戻す\n    df_out = df_out.reset_index(drop=True).sort_values('日時')\n\n    out_path = Path(out_dir) / f\"{prefix}_{start_year}-{end_year}.csv\"\n    df_out.to_csv(out_path, index=False, encoding='utf-8-sig')\n\n    # --- 年ごとの辞書を生成 ---\n    by_year = {}\n    for y, g in df_out.groupby(df_out['日時'].dt.year):\n        by_year[int(y)] = g.reset_index(drop=True)\n\n    out = {\n        'daily': df_out,\n        'by_year': by_year\n    }\n\n    return out\n\n\n# 1) 共通ヘルパ：辞書/DFを単一DataFrameに正規化\ndef _to_daily_df(res: Any) -&gt; pd.DataFrame:\n    if isinstance(res, dict):\n        if 'daily' in res:\n            df = res['daily'].copy()\n        elif 'by_year' in res:\n            df = pd.concat(res['by_year'].values(), ignore_index=True)\n        else:  # {year: df}\n            df = pd.concat(res.values(), ignore_index=True)\n    elif isinstance(res, pd.DataFrame):\n        df = res.copy()\n    else:\n        raise TypeError(\"res は {'daily':df} / {'by_year':{年:df}} / {年:df} / DataFrame を想定\")\n    if not pd.api.types.is_datetime64_any_dtype(df['日時']):\n        df['日時'] = pd.to_datetime(df['日時'], errors='coerce')\n    for c in ('最高気温','最低気温','平均気温'):\n        if c in df.columns:\n            df[c] = pd.to_numeric(df[c], errors='coerce')\n    return df.dropna(subset=['日時']).sort_values('日時').reset_index(drop=True)\n\n# 2) 夏（暦年）サマリー\ndef summarize_summer_calendar(\n    res: Any,\n    *,\n    summer_threshold: float = 25.0,     # 夏日の閾値\n    midsummer_threshold: float = 30.0,  # 真夏日の閾値\n    exhotday_threshold: float = 35.0,  # 猛暑日の閾値\n    start_year: Optional[int] = None,\n    end_year: Optional[int] = None\n) -&gt; pd.DataFrame:\n    df = _to_daily_df(res)\n    df['年'] = df['日時'].dt.year\n    if start_year is None: start_year = int(df['年'].min())\n    if end_year   is None: end_year   = int(df['年'].max())\n\n    is_summer = df['最高気温'] &gt;= summer_threshold\n    first_ = df.loc[is_summer].groupby('年')['日時'].min().rename('初夏日')\n    last_  = df.loc[is_summer].groupby('年')['日時'].max().rename('最終夏日')\n    cnt    = is_summer.groupby(df['年']).sum().astype(int).rename('夏日日数')\n\n    is_midsummer = df['最高気温'] &gt;= midsummer_threshold\n    mid_first_ = df.loc[is_midsummer].groupby('年')['日時'].min().rename('初真夏日')\n    mid_last_  = df.loc[is_midsummer].groupby('年')['日時'].max().rename('最終真夏日')\n    mid_cnt    = is_midsummer.groupby(df['年']).sum().astype(int).rename('真夏日日数')\n\n    is_exsummer = df['最高気温'] &gt;= exhotday_threshold\n    ex_first_ = df.loc[is_exsummer].groupby('年')['日時'].min().rename('初猛暑日')\n    ex_last_  = df.loc[is_exsummer].groupby('年')['日時'].max().rename('最終猛暑日')\n    ex_cnt    = is_exsummer.groupby(df['年']).sum().astype(int).rename('猛暑日日数')\n\n    idx = pd.Index(range(start_year, end_year + 1), name='年')\n    out = pd.concat([first_, cnt, last_,\n                     mid_first_, mid_last_, mid_cnt,\n                     ex_first_, ex_last_, ex_cnt],  axis=1).reindex(idx)\n    out['初夏日_DOY']   = out['初夏日'].dt.dayofyear\n    out['最終夏日_DOY'] = out['最終夏日'].dt.dayofyear\n\n#    print(out)\n    return (out.reset_index()\n              .loc[:, ['年','初夏日','初夏日_DOY','夏日日数','最終夏日','最終夏日_DOY',\n                       '初真夏日', '最終真夏日', '真夏日日数',\n                       '初猛暑日', '最終猛暑日', '猛暑日日数']])\n\n# 3) 冬（寒候期：前年10/1〜当年3/31、ラベル=“1月を含む年”）\ndef summarize_winter_coldseason(\n    res: Any,\n    *,\n    winter_threshold: float = 0.0,          # &lt;0℃（0℃を含めるなら inclusive_zero=True）\n    inclusive_zero: bool = False,           # True で &lt;=0℃ を冬日に\n    cold_start: Tuple[int,int] = (10,1),    # 前年10/1〜\n    cold_end:   Tuple[int,int] = (4,30),    # 当年4/01\n    start_csyear: Optional[int] = None,     # 出力レンジ（“1月を含む年”）\n    end_csyear:   Optional[int] = None,\n    blank_first_initial: bool = True,\n    blank_last_final:   bool = True\n) -&gt; pd.DataFrame:\n    df = _to_daily_df(res)\n    s_m, s_d = cold_start; e_m, e_d = cold_end\n\n    # その日が属する“寒候期年”（1月を含む年）を付与\n    def cs_year(ts: pd.Timestamp):\n        m, d, y = ts.month, ts.day, ts.year\n        if (m &gt; s_m) or (m == s_m and d &gt;= s_d):  # 前年側 → 翌年ラベル\n            return y + 1\n        if (m &lt; e_m) or (m == e_m and d &lt;= e_d):  # 当年側 → 当年ラベル\n            return y\n        return pd.NA\n    df['寒候期年'] = df['日時'].apply(cs_year)\n\n    valid = df['寒候期年'].dropna().astype(int)\n    if valid.empty:\n        return pd.DataFrame(columns=['寒候期年','初冬日','初冬日_DOY',\n                                     '最終冬日','最終冬日_DOY',\n                                     '初真冬日','最終真冬日'])\n    if start_csyear is None: start_csyear = int(valid.min())\n    if end_csyear   is None: end_csyear   = int(valid.max())\n    idx = pd.Index(range(start_csyear, end_csyear + 1), name='寒候期年')\n\n    in_cs = df['寒候期年'].notna()\n    is_winter = (df['最低気温'] &lt;= winter_threshold) if inclusive_zero else (df['最低気温'] &lt; winter_threshold)\n    is_mid_winter = (df['最高気温'] &lt;= winter_threshold) if inclusive_zero else (df['最高気温'] &lt; winter_threshold)\n\n    first_ = df.loc[in_cs & is_winter].groupby('寒候期年')['日時'].min().rename('初冬日')\n    last_  = df.loc[in_cs & is_winter].groupby('寒候期年')['日時'].max().rename('最終冬日')\n  #  cnt    = ((in_cs & is_winter).groupby(df['寒候期年']).sum().astype('Int64').rename('冬日日数'))\n\n    mid_first_ = df.loc[in_cs & is_mid_winter].groupby('寒候期年')['日時'].min().rename('初真冬日')\n    mid_last_  = df.loc[in_cs & is_mid_winter].groupby('寒候期年')['日時'].max().rename('最終真冬日')\n  #  mid_cnt    = ((in_cs & is_mid_winter).groupby(df['寒候期年']).sum().astype('Int64').rename('真冬日日数'))\n\n  #  out = pd.concat([first_, cnt, last_, mid_first_, mid_cnt, mid_last_ ], axis=1).reindex(idx)\n    out = pd.concat([first_, last_, mid_first_, mid_last_ ], axis=1).reindex(idx)\n    out['初冬日_DOY']  = out['初冬日'].dt.dayofyear\n    out['最終冬日_DOY'] = out['最終冬日'].dt.dayofyear\n    out = (out.reset_index()\n             .loc[:, ['寒候期年','初冬日','初冬日_DOY','最終冬日','最終冬日_DOY',\n                      '初真冬日','最終真冬日']])\n\n    # 端年度のブランク指定\n    if not out.empty:\n        if blank_first_initial:\n            out.loc[out.index[0], ['初冬日','初冬日_DOY']] = [pd.NaT, pd.NA]\n        if blank_last_final:\n            out.loc[out.index[-1], ['最終冬日','最終冬日_DOY']] = [pd.NaT, pd.NA]\n    return out\n\n# 3.5) 冬（寒候期：前年10/1〜当年3/31、ラベル=“1月を含む年”）\n#    冬日日数、真冬日日数は暦年でカウント\n\ndef summarize_winter_calendar(\n    res: Any,\n    *,\n    winter_threshold: float = 0.0,      # &lt;0℃（inclusive_zero=True なら &lt;=0℃）\n    inclusive_zero: bool = False,\n    start_year: Optional[int] = None,\n    end_year: Optional[int] = None,\n) -&gt; pd.DataFrame:\n    df = _to_daily_df(res)\n    # ★ これが無くて KeyError: '年' が出ていた\n    df['年'] = df['日時'].dt.year\n\n    if start_year is None:\n        start_year = int(df['年'].min())\n    if end_year is None:\n        end_year = int(df['年'].max())\n    idx = pd.Index(range(start_year, end_year + 1), name='年')\n\n    if inclusive_zero:\n        is_winter     = df['最低気温'] &lt;= winter_threshold   # 冬日：最低気温\n        is_mid_winter = df['最高気温'] &lt;= winter_threshold   # 真冬日：最高気温\n    else:\n        is_winter     = df['最低気温']  &lt; winter_threshold\n        is_mid_winter = df['最高気温']  &lt; winter_threshold\n\n    cnt     = is_winter.groupby(df['年']).sum().astype('Int64').rename('冬日日数')     # 暦年\n    mid_cnt = is_mid_winter.groupby(df['年']).sum().astype('Int64').rename('真冬日日数')  # 暦年\n\n    out = pd.concat([cnt, mid_cnt], axis=1).reindex(idx, fill_value=0).astype('Int64')\n    return out.reset_index()\n\n\n# 4) 結合：年（暦年）と寒候期年を突き合わせ＆自動補完\ndef combine_summer_winter(summer_df: pd.DataFrame, winter_df: pd.DataFrame,\n                          winter_cnt_df: pd.DataFrame) -&gt; pd.DataFrame:\n    merged = pd.merge(\n        summer_df, winter_df, left_on='年', right_on='寒候期年', how='outer'\n    )\n    # 年の補完（夏 or 冬のどちらかにしか無い年を救う）\n    if '年' in merged.columns and '寒候期年' in merged.columns:\n        merged['年'] = merged['年'].astype('Int64')\n        merged['寒候期年'] = merged['寒候期年'].astype('Int64')\n        merged['年'] = merged['年'].fillna(merged['寒候期年'])\n        merged = merged.drop(columns=['寒候期年'])\n\n    merged = pd.merge(\n        merged, winter_cnt_df, left_on='年', right_on='年', how='outer'\n    )\n\n    cols = ['年','初夏日','初夏日_DOY','夏日日数','最終夏日','最終夏日_DOY',\n            '初真夏日', '真夏日日数', '最終真夏日', '初猛暑日', '猛暑日日数', '最終猛暑日',\n            '初冬日','初冬日_DOY','冬日日数','最終冬日','最終冬日_DOY',\n            '初真冬日','真冬日日数','最終真冬日']\n    return (merged[[c for c in cols if c in merged.columns]]\n            .sort_values('年').reset_index(drop=True))\n\n\ndef add_gaps_for_summary(summary: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    summary（combine_summer_winter_tables の出力を想定）に3列を追加:\n      - '最終夏日→翌寒候期初冬日_すき間(日)'\n      - '初冬日→最終冬日(同寒候期)_すき間(日)'\n      - '初夏日→最終夏日(同暦年)_すき間(日)'\n    いずれも端点除外（差の日数から1を引く）。欠損 or 差が負なら NA。\n    \"\"\"\n    df = summary.copy().sort_values('年').reset_index(drop=True)\n\n    def gap_exclusive(later, earlier):\n        if pd.isna(later) or pd.isna(earlier):\n            return pd.NA\n        d = (later - earlier).days - 1\n        return d if d &gt;= 0 else pd.NA\n\n    # 1) 春期間（最終冬日〜初夏日）\n    df['春期間'] = (df['初夏日'] - df['最終冬日']).dt.days - 1\n\n    # 2) 夏期間（初夏日→最終夏日）\n    df['夏期間'] = [\n        gap_exclusive(row['最終夏日'], row['初夏日']) for _, row in df.iterrows()\n    ]\n\n    # 3) 秋期間（最終夏日〜翌寒候期の初冬日）（例: 1961年は 1962行の初冬日＝1961-11-14 を使用）\n    next_season_first_winter = df['初冬日'].shift(-1)  # Y+1 シーズンの初冬日\n    df['秋期間'] = [\n        gap_exclusive(nfw, ls) for nfw, ls in zip(next_season_first_winter, df['最終夏日'])\n    ]\n\n    # 4) 冬期間（初冬日→最終冬日（同一寒候期））\n    df['冬期間'] = [\n        gap_exclusive(row['最終冬日'], row['初冬日']) for _, row in df.iterrows()\n    ]\n\n    return df\n\n\n# 5) 取得→サマリー→結合を1発で（冬のため開始年-1で自動取得）\ndef build_summary_for_place(\n    *, pref: str, place: str, start_year: int, end_year: int,\n    summer_threshold: float = 25.0,\n    midsummer_threshold: float = 30.0,\n    exhotday_threshold: float = 35.0,\n    winter_threshold: float = 0.0,\n    inclusive_zero: bool = False,\n    cold_start=(10,1), cold_end=(3,31)\n) -&gt; pd.DataFrame:\n    info = ml.getBlock(pref, place)\n    prec, block = info['prec'], info['block']\n    \n    # ★ キャッシュ経路：前年Q4も含めて取得\n    res = build_daily_with_cache(\n        prec=prec, block=block,\n        start_year=start_year, end_year=end_year,\n        fetch_func=ml.get_DailyData,\n        need_prev_year_for_coldseason=True\n    )\n\n    summer = summarize_summer_calendar(\n        res, summer_threshold=summer_threshold,\n        midsummer_threshold=midsummer_threshold,\n        exhotday_threshold=exhotday_threshold,\n        start_year=start_year, end_year=end_year\n    )\n    winter = summarize_winter_coldseason(\n        res, winter_threshold=winter_threshold, inclusive_zero=inclusive_zero,\n        cold_start=cold_start, cold_end=cold_end,\n        start_csyear=start_year, end_csyear=end_year,\n        blank_first_initial=True, blank_last_final=True\n    )\n    winter_cnt = summarize_winter_calendar(\n        res, winter_threshold=winter_threshold, inclusive_zero=inclusive_zero,\n        start_year=start_year, end_year=end_year,\n    )\n\n    summary = combine_summer_winter(summer, winter, winter_cnt)\n\n    # ここでギャップ列を追加\n    summary = add_gaps_for_summary(summary)\n\n    return summary\n\n\n# =========================\n#  JMA 高速ローダ（キャッシュ付）\n#  - 月次Parquetキャッシュ\n#  - dtype固定（float32）\n#  - 並列読み込み（ローカルParquetのみ）\n# =========================\n\nfrom __future__ import annotations\nfrom pathlib import Path\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nimport time\nimport pandas as pd\nimport numpy as np\nimport os\n\n# ---- 設定 ----\nCACHE_DIR = Path(\"jma_cache_parquet\")   # キャッシュのルート\nPARQUET_COMPRESSION = None              # 実行時に zstd/snappy を選ぶ（Noneで自動）\n\n# ---- 圧縮方式の自動選択 ----\ndef _choose_parquet_compression() -&gt; str:\n    # pyarrowがzstdをサポートしていなければsnappyへ\n    # 失敗したら非圧縮（None）にフォールバック\n    try:\n        import pyarrow\n        from pyarrow import codec\n        # 新旧でAPIが異なるので雑にtry\n        for name in (\"zstd\", \"ZSTD\"):\n            try:\n                codec.is_available(name)\n                return \"zstd\"\n            except Exception:\n                pass\n        return \"snappy\"\n    except Exception:\n        return None\n\nif PARQUET_COMPRESSION is None:\n    PARQUET_COMPRESSION = _choose_parquet_compression()\n\n# ---- ヘルパ：月ファイルのパス ----\ndef _month_cache_path(prec: int, block: int, year: int, month: int) -&gt; Path:\n    return CACHE_DIR / f\"{prec}_{block}\" / f\"{year:04d}\" / f\"{year:04d}-{month:02d}.parquet\"\n\n# ---- 型そろえ（高速I/O向けに軽量dtypeで統一）----\nDTYPE_MAP = {\n    \"平均気温\": \"float32\",\n    \"最高気温\": \"float32\",\n    \"最低気温\": \"float32\",\n}\nDATE_COL = \"日時\"\nVALUE_COLS = [\"平均気温\", \"最高気温\", \"最低気温\"]\n\ndef _coerce_daily_df(df: pd.DataFrame) -&gt; pd.DataFrame:\n    df = df[[DATE_COL] + VALUE_COLS].copy()\n    # 既にdatetimeなら速い・未変換ならformat指定で高速化\n    if not pd.api.types.is_datetime64_any_dtype(df[DATE_COL]):\n        df[DATE_COL] = pd.to_datetime(df[DATE_COL], format=\"%Y-%m-%d\", errors=\"coerce\")\n    for c in VALUE_COLS:\n        df[c] = pd.to_numeric(df[c], errors=\"coerce\").astype(DTYPE_MAP[c])\n    df = df.dropna(subset=[DATE_COL]).sort_values(DATE_COL).reset_index(drop=True)\n    return df\n\n# ---- 1ヶ月取得＋キャッシュ保存（未キャッシュ時のみ）----\ndef load_month_cached(prec: int, block: int, year: int, month: int,\n                      fetch_func,\n                      *, force_refresh: bool = False,\n                      polite_sleep_sec: float = 0.8,\n                      max_retries: int = 3) -&gt; pd.DataFrame:\n    \"\"\"\n    fetch_func(prec, block, year, month, day) -&gt; DataFrame\n    未キャッシュなら取得→Parquet保存、既にあれば読み込みのみ。\n    \"\"\"\n    path = _month_cache_path(prec, block, year, month)\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    if path.exists() and not force_refresh:\n        # Parquetは型保持のため超速\n        return pd.read_parquet(path)\n\n    last_err = None\n    for trial in range(1, max_retries + 1):\n        try:\n            # JMAは月表を day=1 で取得する実装を想定\n            df_m = fetch_func(prec, block, year, month, 1)\n            df_m = df_m.reset_index(names=\"日時\")\n            df_m = _coerce_daily_df(df_m)\n            df_m.to_parquet(path, index=False, compression=PARQUET_COMPRESSION)\n            return df_m\n        except Exception as e:\n            last_err = e\n            if trial &lt; max_retries:\n                time.sleep(polite_sleep_sec)\n                continue\n            raise RuntimeError(f\"月データ取得失敗: {year}-{month:02d} ({e})\") from e\n    # 到達しないはず\n    raise last_err  # noqa\n\n# ---- 期間読み込み（キャッシュ優先、未キャッシュのみ取得）----\ndef make_multi_year_cached(prec: int, block: int,\n                           start_year: int, end_year: int,\n                           fetch_func,\n                           *, drop_feb29: bool = True,\n                           parallel_read: bool = True,\n                           max_workers: int | None = None) -&gt; pd.DataFrame:\n    \"\"\"\n    指定期間の全月を用意（キャッシュがあれば読む／無ければ取得・保存）。\n    読み込み段階はParquetを並列で読むことで高速化（ネット取得は逐次）。\n    \"\"\"\n    # まずファイルの存在を調べ、未キャッシュ分だけ順次取得して保存\n    tasks = []\n    for y in range(start_year, end_year + 1):\n        for m in range(1, 13):\n            p = _month_cache_path(prec, block, y, m)\n            tasks.append((y, m, p))\n    # 未キャッシュを先に取得（逐次＝礼儀）\n    for (y, m, p) in tasks:\n        if not p.exists():\n            _ = load_month_cached(prec, block, y, m, fetch_func, force_refresh=False)\n\n    # ここまで来たら全月がParquetで存在 → 並列で読み込む\n    def _read_parquet(pth: Path) -&gt; pd.DataFrame:\n        return pd.read_parquet(pth)\n\n    frames: list[pd.DataFrame] = []\n    if parallel_read:\n        if max_workers is None:\n            max_workers = min(32, (os.cpu_count() or 4))\n        with ThreadPoolExecutor(max_workers=max_workers) as ex:\n            futs = {ex.submit(_read_parquet, p): (y, m) for (y, m, p) in tasks}\n            for fu in as_completed(futs):\n                df_m = fu.result()\n                frames.append(df_m)\n    else:\n        for (_, _, p) in tasks:\n            frames.append(pd.read_parquet(p))\n\n    df = pd.concat(frames, ignore_index=True)\n    # 重複日除去＆整形\n    df = df.dropna(subset=[DATE_COL]).sort_values(DATE_COL)\n    df = df[~df[DATE_COL].duplicated(keep=\"first\")]\n    if drop_feb29:\n        md = df[DATE_COL]\n        df = df[~((md.dt.month == 2) & (md.dt.day == 29))]\n    return df.reset_index(drop=True)\n\n\n# ---- 既存フローとの接続ユーティリティ（res={'daily': df} を返す）----\ndef build_daily_with_cache(*, prec: int, block: int,\n                           start_year: int, end_year: int,\n                           fetch_func,\n                           need_prev_year_for_coldseason: bool = True) -&gt; dict[str, pd.DataFrame]:\n    \"\"\"\n    冬の寒候期のために開始年を自動で -1 して取得するオプション付き。\n    \"\"\"\n    s = start_year - 1 if need_prev_year_for_coldseason else start_year\n    df = make_multi_year_cached(\n        prec, block, start_year=s, end_year=end_year,\n        fetch_func=fetch_func,\n        drop_feb29=True,\n        parallel_read=True\n    )\n    return {\"daily\": df}\n\n\n\"\"\"\nprec_list = {\n    \"宗谷総合振興局\":11, \"上川総合振興局\":12, \"留萌振興局\":13, \"石狩振興局\":14,\n    \"空知総合振興局\":15, \"後志総合振興局\":16, \"オホーツク総合振興局\":17,\n    \"根室振興局\":18, \"釧路総合振興局\":19, \"十勝総合振興局\":20, \"胆振総合振興局\":21,\n    \"日高振興局\":22, \"渡島総合振興局\":23, \"檜山振興局\":24,\n    \"青森県\":31, \"秋田県\":32, \"岩手県\":33, \"宮城県\":34, \"山形県\":35, \"福島県\":36,\n    \"茨城県\":40, \"栃木県\":41, \"群馬県\":42, \"埼玉県\":43, \"東京都\":44, \"千葉県\":45,\n    \"神奈川県\":46, \"長野県\":48, \"山梨県\":49, \"静岡県\":50, \"愛知県\":51, \"岐阜県\":52,\n    \"三重県\":53, \"新潟県\":54, \"富山県\":55, \"石川県\":56, \"福井県\":57,\n    \"滋賀県\":60, \"京都府\":61, \"大阪府\":62, \"兵庫県\":63, \"奈良県\":64, \"和歌山県\":65,\n    \"岡山県\":66, \"広島県\":67, \"島根県\":68, \"鳥取県\":69, \"徳島県\":71, \"香川県\":72,\n    \"愛媛県\":73, \"高知県\":74,\n    \"山口県\":81, \"福岡県\":82, \"大分県\":83, \"長崎県\":84, \"佐賀県\":85, \"熊本県\":86,\n    \"宮崎県\":87, \"鹿児島県\":88,\n    \"沖縄県\":91, \"南大東村\":92, \"北大東村\":92, \"宮古島市\":93, \"宮古郡\":93,\n    \"石垣市\":94, \"八重山郡\":94}\n\"\"\"\n# 1) 地点指定\npref, place, start_year, end_year = \"宮城県\", \"仙台\", 1926, 2024\ninfo = ml.getBlock(pref, place)\nprint(info)\nprec = info['prec']\nblock = info['block']\nst_name = info['Name_2']\nprint(st_name)\n# 2) 高速ロード（未キャッシュは取得→保存、以降は爆速ロード）\nres = build_daily_with_cache(\n    prec=prec, block=block,\n    start_year=start_year, end_year=end_year,\n    fetch_func=ml.get_DailyData,\n    need_prev_year_for_coldseason=True  # 冬（前年10月）を含める用に開始年-1で取得\n)\ndrive_path = \"/Users/takumi/projects/JMA-data\"\ndrive_path = Path(drive_path)\noutdir = drive_path / \"outputs\"\noutdir.mkdir(parents=True, exist_ok=True)\nbasename= f\"日毎データ_{place}\"\next1 = \".parquet\"\next2 = \".csv\"\n#print(outfile)\ndf_daily = res['daily']\n#print(df_daily, place)\noutfile1 = (outdir / basename).with_suffix(ext1)\noutfile2 = (outdir / basename).with_suffix(ext2)\ndf_daily.to_parquet(outfile1, index=False, compression='zstd')\ndf_daily.to_csv(outfile2, index=False, encoding='utf-8-sig')\n\n# 3) 以降は従来フローのまま\nsummary = build_summary_for_place(\n    pref=pref, place=place,\n    start_year=start_year, end_year=end_year,     # ← 表示レンジ\n    summer_threshold=25.0,\n    midsummer_threshold=30.0,\n    exhotday_threshold=35.0,\n    winter_threshold=0.0,\n    inclusive_zero=False,               # True で 0.0℃ も冬日に含める\n    cold_start=(10,1), cold_end=(4,30)  # 1月を含む冬期間：前年10/1〜当4/30\n)\ndisplay(summary)\nsummary.to_parquet(OUT / f'日毎データ_{place}_summary.parquet', index=False, compression='zstd')\nsummary.to_csv(OUT / f'日毎データ_{place}_summary.csv', index=False, encoding='utf-8-sig')\n\nprint(\"Finish\")\n\n{'prec': 34, 'block': 47590, 'Name_2': 'SENDAI', 'Alt': 39.0, 'H_Anemo': 52.0, 'Lat': 38.262, 'Lon': 140.897}\nSENDAI\n\n\n\n\n\n\n\n\n\n年\n初夏日\n初夏日_DOY\n夏日日数\n最終夏日\n最終夏日_DOY\n初真夏日\n真夏日日数\n最終真夏日\n初猛暑日\n...\n冬日日数\n最終冬日\n最終冬日_DOY\n初真冬日\n真冬日日数\n最終真冬日\n春期間\n夏期間\n秋期間\n冬期間\n\n\n\n\n0\n1926\nNaT\nNaN\n0\nNaT\nNaN\nNaT\n0\nNaT\nNaT\n...\n33\nNaT\nNaN\nNaT\n0\nNaT\nNaN\n&lt;NA&gt;\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n1\n1927\n1927-05-21\n141.0\n75\n1927-10-03\n276.0\n1927-07-17\n14\n1927-08-24\nNaT\n...\n109\n1927-03-29\n88.0\n1927-01-19\n9\n1927-02-05\n52.0\n134\n48\n140\n\n\n2\n1928\n1928-06-09\n161.0\n54\n1928-09-25\n269.0\n1928-07-16\n5\n1928-09-14\nNaT\n...\n104\n1928-04-21\n112.0\n1928-01-13\n2\n1928-02-08\n48.0\n107\n46\n151\n\n\n3\n1929\n1929-05-31\n151.0\n69\n1929-10-08\n281.0\n1929-07-11\n32\n1929-09-03\n1929-07-18\n...\n106\n1929-04-06\n96.0\n1929-01-03\n5\n1929-03-03\n54.0\n129\n42\n145\n\n\n4\n1930\n1930-04-19\n109.0\n71\n1930-09-23\n266.0\n1930-07-03\n20\n1930-09-03\nNaT\n...\n100\n1930-03-25\n84.0\n1930-01-08\n2\n1930-01-09\n24.0\n156\n49\n124\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n94\n2020\n2020-05-02\n123.0\n90\n2020-09-23\n267.0\n2020-05-02\n32\n2020-09-09\n2020-08-15\n...\n31\n2020-02-12\n43.0\nNaT\n1\nNaT\n79.0\n143\n82\n74\n\n\n95\n2021\n2021-05-08\n128.0\n88\n2021-10-15\n288.0\n2021-07-06\n28\n2021-08-30\nNaT\n...\n56\n2021-03-09\n68.0\n2020-12-31\n2\n2021-01-08\n59.0\n159\n63\n83\n\n\n96\n2022\n2022-04-13\n103.0\n94\n2022-10-04\n277.0\n2022-06-20\n32\n2022-08-23\n2022-06-25\n...\n66\n2022-03-23\n82.0\nNaT\n0\nNaT\n20.0\n173\n59\n94\n\n\n97\n2023\n2023-04-14\n104.0\n117\n2023-10-03\n276.0\n2023-05-18\n66\n2023-09-20\n2023-07-16\n...\n54\n2023-03-05\n64.0\n2023-01-25\n1\n2023-01-25\n39.0\n171\n74\n91\n\n\n98\n2024\n2024-04-15\n106.0\n120\n2024-10-24\n298.0\n2024-06-14\n56\n2024-10-02\n2024-07-22\n...\n50\nNaT\nNaN\nNaT\n0\nNaT\nNaN\n191\n&lt;NA&gt;\n&lt;NA&gt;\n\n\n\n\n99 rows × 24 columns\n\n\n\nFinish\n\n\n\n# データチェックのための作図\n# ---- 前提 ----\n# summary: DataFrame に以下の列があること:\n#   年, 最終夏日, 初冬日, 秋期間\n\nREF_YEAR = 2001\nFALL_COL = \"秋期間\"  # ←計算済みの列名をそのまま使用\n\ndf = summary.copy().sort_values(\"年\").reset_index(drop=True)\ndf[\"翌寒候期初冬日\"] = df[\"初冬日\"].shift(-1)  # 折れ線用：翌シーズンの初冬日\n\ndef to_refdate(s: pd.Series) -&gt; pd.Series:\n    # 年を消して「月日だけ」を基準年に載せ替え（NaTはNaTのまま）\n    return pd.to_datetime(\n        np.where(s.notna(), s.dt.strftime(f\"{REF_YEAR}\" + \"-%m-%d\"), pd.NaT),\n        errors=\"coerce\"\n    )\n\nfinal_summer_ref = to_refdate(df[\"最終夏日\"])\nnext_first_winter_ref = to_refdate(df[\"翌寒候期初冬日\"])\nx = df[\"年\"].astype(int).values\n\nfig, ax1 = plt.subplots(figsize=(10, 5))\n\n# 左軸：月日（折れ線）\nax1.plot(x, final_summer_ref, marker=\"o\", label=\"最終夏日（暦年）\")\nax1.plot(x, next_first_winter_ref, marker=\"s\", label=\"翌寒候期初冬日\")\nax1.set_ylabel(\"月日\")\nax1.yaxis.set_major_formatter(DateFormatter(\"%m-%d\"))\nax1.set_xlabel(\"年\")\nax1.tick_params(axis='x', labelrotation=45)\ny1_min = dt.date(REF_YEAR, 6, 1)\ny1_max = dt.date(REF_YEAR + 1, 1, 1)\nax1.set_ylim(y1_min, y1_max)\n# --- y軸ラベルを9月〜12月の1か月ごとに ---\ntick_dates = pd.date_range(start=f\"{REF_YEAR}-09-01\", end=f\"{REF_YEAR + 1}-01-01\", freq=\"MS\")\n#tick_dates = pd.date_range(start=f\"{REF_YEAR}-09-01\", end=f\"{REF_YEAR}-12-01\", freq=\"MS\")\nax1.set_yticks(tick_dates)\nax1.yaxis.set_major_formatter(mdates.DateFormatter(\"%m-%d\"))\n\n\n# 右軸：秋期間（日）（棒）\nax2 = ax1.twinx()\ny = pd.to_numeric(df[FALL_COL], errors='coerce').fillna(0.0)\nax2.bar(x, y.values.astype(\"float\"), alpha=0.3, label=\"秋期間（日）\")\nax2.set_ylabel(\"日数\")\nax2.set_ylim(0, 250)\nticks = list(range(0, 101, 20))\nax2.set_yticks(ticks)\n\n\n# 凡例（統合）\nhandles, labels = [], []\nfor ax in (ax1, ax2):\n    h, l = ax.get_legend_handles_labels()\n    handles += h; labels += l\nseen, h2, l2 = set(), [], []\nfor h, l in zip(handles, labels):\n    if l not in seen:\n        seen.add(l); h2.append(h); l2.append(l)\nax1.legend(h2, l2, loc=\"best\")\n\nax1.grid(True, linestyle=\"--\", linewidth=0.5, alpha=0.6)\nplt.title(f\"最終夏日〜初冬日と秋期間（日数）  {place}\")\nplt.tight_layout()\n\n#plt.savefig(f'{place}_{start_year}-{end_year}_秋日数.png')\n\nplt.show()"
  },
  {
    "objectID": "notebooks/python/体感温度による秋判定.html",
    "href": "notebooks/python/体感温度による秋判定.html",
    "title": "",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\n\nfrom meteo_lib import PROJECT  # または: from meteo_lib.paths import PROJECT\n#out_dir  = PROJECT / \"outputs\"\n\nfrom meteo_lib.meteo_lib import getBlock, get_HourlyData, get_10minData\nfrom meteo_lib.my_path_utils import DATA, OUT\n\nimport pandas as pd\nimport math\nimport numpy as np\nfrom datetime import datetime, timedelta, date, time\nfrom metpy.units import units\nfrom metpy.calc import dewpoint_from_relative_humidity\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nmpl.rcParams[\"font.family\"] = \"Hiragino Sans\"   # 例：Noto Sans CJK JP でも可\nmpl.rcParams[\"axes.unicode_minus\"] = False    # －が豆腐になるのを回避\n\nimport matplotlib.dates as mdates\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.ticker import FuncFormatter, MultipleLocator\nimport os\nfrom pathlib import Path\nimport calendar\nfrom IPython.display import display \n\n\n# 移動平均：5日　　持続窓：7日　　多数決：5/7　　快適帯：18℃ ≤ AT ≤ 24℃　　\n# 秋入り：24℃以下  秋明け：18℃未満\n\ndef _first_true_in_window(flag_window: pd.Series):\n    \"\"\"window内で最初にTrueになった日付を返す（なければNone）\"\"\"\n    idx = flag_window.index[flag_window.to_numpy()]\n    return idx[0] if len(idx) else None\n\ndef _find_event_by_majority_on_daily(\n    flag: pd.Series,\n    window: int,\n    majority: int,\n    start_date: pd.Timestamp | None = None,\n    end_date: pd.Timestamp | None = None,\n):\n    \"\"\"\n    flag: 日次（D）のbool Series（indexは連続日付であること）\n    window日間のうち majority日以上 True なら成立。\n    成立したら、その成立窓の中で最初にTrueになった日を返す。\n    \"\"\"\n    f = flag.copy()\n\n    if start_date is not None:\n        f = f.loc[start_date:]\n    if end_date is not None:\n        f = f.loc[:end_date]\n\n    if len(f) &lt; window:\n        return None\n\n    arr = f.to_numpy(dtype=bool)\n    # 7日多数決（rolling sum）\n    roll = pd.Series(arr.astype(int), index=f.index).rolling(window, min_periods=window).sum()\n\n    hit = roll &gt;= majority\n    if not hit.any():\n        return None\n\n    d_star = hit.idxmax()  # 最初に成立した日（rollingの右端日）\n    win = f.loc[d_star - pd.Timedelta(days=window-1) : d_star]\n    return _first_true_in_window(win)\n\ndef _end_of_month(year: int, month: int) -&gt; pd.Timestamp:\n    \"\"\"その月の月末日（Timestamp）\"\"\"\n    return (pd.Timestamp(year, month, 1) + pd.offsets.MonthEnd(0))\n\ndef _make_year_span(start: pd.Timestamp, end_month: int) -&gt; tuple[pd.Timestamp, pd.Timestamp]:\n    \"\"\"\n    start日から、(startの年/翌年)のend_month末までの期間を返す。\n    end_monthが start.month より小さいなら翌年のend_monthまで。\n    例：start=2020-09-15, end_month=2 -&gt; 2021-02-28(末)\n    \"\"\"\n    y0 = start.year\n    y1 = y0 + (1 if end_month &lt; start.month else 0)\n    end_dt = _end_of_month(y1, end_month)\n    return start, end_dt\n\ndef find_autumn_periods_multi(\n    csv_path: str,\n    cols=(\"AT\", \"AT_daily\", \"temp\", \"temp_daily\"),\n    date_col=\"日時\",\n    ma_days=5,\n    window=7,\n    majority=5,\n    th_hi=24.0,\n    th_lo=18.0,\n    # 探索制限（任意）\n    use_peak_after=True,     # ★秋入り探索を「夏ピーク後」に限定（推奨）\n    peak_search_months=(6, 9),# 夏ピーク探索範囲（月）。例：6-9月の最大をピークとみなす\n    start_month_hi=7,        # 秋入り探索の月制限（任意で併用）\n    end_month_hi=12,\n    end_month_lo=2,          # 秋明け探索は翌年2月末まで等\n    min_gap_days_after_peak=0,# ピーク直後のノイズ回避（例：7日など）\n    # デバッグ列を返すか\n    return_debug=False,\n):\n    \"\"\"\n    各年・各系列について：\n      - MA(5日)を作る\n      - 秋入り：MA &lt;= th_hi を (window日中 majority日) で成立、ただし原則「夏ピーク後」から探索\n      - 秋明け：MA &lt; th_lo を (window日中 majority日) で成立（秋入り後〜翌年end_month_lo末）\n    \"\"\"\n\n    df_raw = pd.read_csv(csv_path, parse_dates=[date_col]).set_index(date_col).sort_index()\n\n    # 連続日付の骨格（欠測があっても窓の定義が崩れない）\n    full_index = pd.date_range(df_raw.index.min(), df_raw.index.max(), freq=\"D\")\n    df_raw = df_raw.reindex(full_index)\n\n    years = sorted(pd.Index(full_index.year).unique())\n    out_rows = []\n\n    debug_store = {}  # {col: df_debug}\n\n    for col in cols:\n        if col not in df_raw.columns:\n            raise KeyError(f\"column '{col}' not found in CSV\")\n\n        s = df_raw[col].astype(float)\n\n        # 移動平均（端はNaN、欠測もNaNのまま）\n        ma = s.rolling(ma_days, min_periods=ma_days).mean()\n\n        # True/Falseフラグ：NaNはFalse扱い（多数決で不利＝データ不足）\n        cool = (ma &lt;= th_hi).fillna(False)\n        cold = (ma &lt; th_lo).fillna(False)\n\n        # --- デバッグ用：1970年9月の中身を確認 ---\n        #check = pd.DataFrame({\n        #    \"value\": s,\n        #    \"MA\": ma,\n        #    \"cool\": cool,\n        #    \"cold\": cold,\n        #    \"roll7_cold\": cold.astype(int).rolling(7, min_periods=7).sum(),\n        #}, index=full_index)\n\n        #print(f\"\\n=== DEBUG series={col} ===\")\n        #print(check.loc[\"1970-09-20\":\"1970-09-30\"])\n\n        \n        if return_debug:\n            debug_store[col] = pd.DataFrame({\"value\": s, \"MA\": ma, \"cool\": cool, \"cold\": cold}, index=full_index)\n\n        for y in years:\n            year_start = pd.Timestamp(y, 1, 1)\n            year_end   = pd.Timestamp(y, 12, 31)\n\n            # その年の範囲に切り出し（秋入り探索対象）\n            ma_y   = ma.loc[year_start:year_end]\n            cool_y = cool.loc[year_start:year_end]\n\n            # --- 秋入り探索の開始点を決める ---\n            start_search = pd.Timestamp(y, start_month_hi, 1)\n            end_search   = _end_of_month(y, end_month_hi)\n\n            # まず月制限（任意。冬誤検出を抑える最低限のガード）\n            cool_search = cool_y.loc[start_search:end_search]\n\n            # さらに「夏ピーク後」に限定（これが冬/春誤検出を根絶）\n            if use_peak_after:\n                pm0, pm1 = peak_search_months\n                peak_start = pd.Timestamp(y, pm0, 1)\n                peak_end   = _end_of_month(y, pm1)\n\n                ma_peak = ma_y.loc[peak_start:peak_end].dropna()\n                if ma_peak.empty:\n                    autumn_start = None\n                else:\n                    t_peak = ma_peak.idxmax()\n                    t0 = t_peak + pd.Timedelta(days=min_gap_days_after_peak)\n                    # ピーク後かつ月制限内\n                    t0 = max(t0, start_search)\n                    cool_search2 = cool_y.loc[t0:end_search]\n                    autumn_start = _find_event_by_majority_on_daily(\n                        cool_search2, window=window, majority=majority\n                    )\n            else:\n                autumn_start = _find_event_by_majority_on_daily(\n                    cool_search, window=window, majority=majority\n                )\n\n            # 秋入りが見つからない年\n            if autumn_start is None:\n                out_rows.append({\n                    \"year\": y, \"series\": col,\n                    \"autumn_start\": pd.NaT, \"autumn_end\": pd.NaT,\n                    \"length_days\": np.nan\n                })\n                continue\n\n            # --- 秋明け探索（秋入り以降〜翌年end_month_lo末） ---\n            span_start, span_end = _make_year_span(autumn_start, end_month=end_month_lo)\n\n            cold_span = cold.loc[span_start:span_end]\n\n            autumn_end = _find_event_by_majority_on_daily(\n                cold_span, window=window, majority=majority\n            )\n\n            length = (autumn_end - autumn_start).days + 1 if pd.notna(autumn_end) else np.nan\n\n            out_rows.append({\n                \"year\": y, \"series\": col,\n                \"autumn_start\": autumn_start,\n                \"autumn_end\": autumn_end,\n                \"length_days\": length\n            })\n\n    out = pd.DataFrame(out_rows).sort_values([\"series\", \"year\"]).reset_index(drop=True)\n\n    # 横持ち（seriesごとに列化）したいならピボット\n    out_wide = (out.pivot(index=\"year\", columns=\"series\", values=[\"autumn_start\", \"autumn_end\", \"length_days\"])\n                  .sort_index())\n\n    if return_debug:\n        return out, out_wide, debug_store\n    return out, out_wide\n\n\ncsv_path = DATA / \"AT_仙台_1970-2024.csv\"\ntry:\n    out_long, out_wide = find_autumn_periods_multi(\n        csv_path,\n        cols=(\"AT\", \"AT_daily\", \"temp\", \"temp_daily\"),\n        th_hi=24, th_lo=18,\n        ma_days=5, window=7, majority=5,\n        use_peak_after=True,          # ★重要：ピーク後探索\n            peak_search_months=(6, 9),    # 夏ピークは6-9月から取る（調整可）\n            start_month_hi=7, end_month_hi=12,  # 念のため月制限も併用\n            end_month_lo=2,               # 冬入り探索は翌年2月末まで\n            min_gap_days_after_peak=0,    # 必要なら7とかに\n        )\n    print(\"CALL DONE\")\n#    print(out_long.head())\n#    display(out_wide)\nexcept Exception as e:\n    print(\"ERROR:\", type(e).__name__, e)\n    raise\n\ndisplay(out_wide.head())\n#display(out_wide)\n\nout_path = OUT /  \"体感温度_仙台.csv\"\nout_wide.to_csv(out_path)\n\n\ndf_A = out_wide.xs(\"autumn_start\", level=0, axis=1)\ndf_A.head()\n\n\n\n\n\n\n\nseries\nAT\nAT_daily\ntemp\ntemp_daily\n\n\nyear\n\n\n\n\n\n\n\n\n1970\n1970-09-07\n1970-09-15\n1970-08-03\n1970-08-06\n\n\n1971\n1971-08-18\n1971-08-19\n1971-08-17\n1971-08-19\n\n\n1972\n1972-08-23\n1972-08-24\n1972-08-22\n1972-08-23\n\n\n1973\n1973-09-06\n1973-09-07\n1973-09-05\n1973-09-07\n\n\n1974\n1974-09-08\n1974-09-09\n1974-08-17\n1974-08-29\n\n\n\n\n\n\n\n\n#fig, ax1 = plt.subplots(figsize=(10, 5))\nfor s in out_wide.columns.levels[1]:\n    df_s = out_wide.xs(s, level=\"series\", axis=1)\n    fig, ax = plt.subplots()\n    ax.plot(df_s.index, df_s[\"length_days\"], linestyle=\"\", marker=\"o\")\n    ax.set_title(f\"Series {s}\")\n    ax.set_ylabel(\"Autumn length (days)\")\n    ax.set_xlabel(\"Year\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndf = out_wide.xs(\"autumn_start\", level=0, axis=1)\n#df = out_wide.xs(\"autumn_start\", level=0, axis=1)\n#index : year (1970, 1971, ...)\n#columns : series (AT, AT_daily, temp, temp_daily)\n#values : datetime64[ns]\n\ndf_doy = df.apply(lambda s: s.dt.dayofyear)    # datetime=&gt;DOY(day of year)\nfig, ax = plt.subplots(figsize=(7, 4))\n\nfor col in df_doy.columns:\n    ax.plot(df_doy.index, df_doy[col], marker=\"o\", label=col)\n\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Day of Year\")\nax.set_title(\"Autumn start (month-day comparison)\")\nax.legend()\n\nimport matplotlib.dates as mdates\nfrom datetime import datetime\n\ndef doy_to_mmdd(doy):\n    return datetime(2001, 1, 1) + pd.to_timedelta(doy - 1, unit=\"D\")\n\nax.yaxis.set_major_formatter(\n    lambda x, pos: doy_to_mmdd(int(x)).strftime(\"%m/%d\")\n)\n\nplt.show()"
  },
  {
    "objectID": "reports/生物季節観測相関.html#相関ヒートマップspearman",
    "href": "reports/生物季節観測相関.html#相関ヒートマップspearman",
    "title": "生物季節観測データの相互相関解析",
    "section": "相関ヒートマップ（Spearman）",
    "text": "相関ヒートマップ（Spearman）\n\n\n\n\n\n同種・同じ季節の現象は強い正相関\n春の現象と夏以降の高温は強い負相関\n秋の現象と夏〜秋の高温は強い正相関"
  },
  {
    "objectID": "reports/生物季節観測相関.html#検討内容",
    "href": "reports/生物季節観測相関.html#検討内容",
    "title": "生物季節観測データの相互相関解析",
    "section": "検討内容",
    "text": "検討内容\n\n生物季節観測（特に、かえで や いちょう）が「秋が短くなった」ことを表現できている　⇒　深掘りしてみたい\n使ったデータ: 仙台 における生物季節観測データ および 月平均気温から算出した季節平均値\n生物季節観測は年の初め（1月1日）から数えて何日目（Days of Year） で表現した\nspring:3〜5月、summer:6〜8月、autumn:9〜11月、winter:12〜2月　 の平均気温\n下表は表の抜粋\n\n\n\n\n\n\n年\nさくら開花\nすすき開花\nいちょう黄葉\nspring\nautumn\nwinter\n\n\n\n\n1953\n101\nNA\nNA\n9.4\n13.5\n2.7\n\n\n1954\n96\nNA\nNA\n10.0\n14.5\n2.1\n\n\n1955\n101\nNA\nNA\n9.8\n14.0\n1.9\n\n\n1956\n106\nNA\n320\n9.5\n14.4\n1.1\n\n\n1957\n106\nNA\n310\n9.1\n14.2\n2.7"
  },
  {
    "objectID": "reports/生物季節観測相関.html#考察",
    "href": "reports/生物季節観測相関.html#考察",
    "title": "生物季節観測データの相互相関解析",
    "section": "考察",
    "text": "考察\n\nうめ開花はばらつきが大きい\nさくら開花・満開は共に早まっている\nあじさい開花は遅くなる傾向、すすき開花は明瞭に早まっている\nいちょう、かえで共に黄葉／紅葉、落葉共に早まっている\n観測項目同士、観測項目と各季節、あるいは各季節間の相関はどうなっているか？"
  },
  {
    "objectID": "reports/生物季節観測相関.html#生物季節どうしの関係左上ブロック",
    "href": "reports/生物季節観測相関.html#生物季節どうしの関係左上ブロック",
    "title": "生物季節観測データの相互相関解析",
    "section": "生物季節どうしの関係（左上ブロック）",
    "text": "生物季節どうしの関係（左上ブロック）\n春の生物季節\n\nさくら開花〜さくら満開：0.95、うめ開花〜さくら開花：0.27\n同一種内（開花→満開）は極めて高相関\n異種でも春イベント間は正相関だが、ばらつきはある（うめとさくら）.\n\n秋の生物季節\n\nいちょう黄葉〜いちょう落葉：0.82、いちょう黄葉〜かえで紅葉：0.78\n秋イベントは 春よりも相関が全体に高め.\n\n春 ↔︎ 秋の生物季節（負相関）\n\nさくら開花 〜 いちょう黄葉：−0.53、すすき開花 〜 いちょう黄葉：−0.74\n春が早い年ほど、秋は遅れる\n季節の引き伸ばし（春の前倒し＋秋の後ろ倒し）を明確に示唆\n「夏が長くなっている感覚」と一致"
  },
  {
    "objectID": "reports/生物季節観測相関.html#生物季節-季節平均気温右側ブロック",
    "href": "reports/生物季節観測相関.html#生物季節-季節平均気温右側ブロック",
    "title": "生物季節観測データの相互相関解析",
    "section": "生物季節 × 季節平均気温（右側ブロック）",
    "text": "生物季節 × 季節平均気温（右側ブロック）\n春イベント × 気温\n\nさくら開花 × spring：−0.79、さくら開花 × summer：−0.33\n春が暖かい年ほど DOYが小さい（＝早い）\n特に spring 気温が支配的\n\n秋イベント × 気温\n\nいちょう黄葉 × autumn：+0.73、いちょう落葉 × autumn：+0.77\n秋が暖かいほど 黄葉・落葉が遅れる\n秋イベントは autumn 気温に最も敏感\n\nすすき開花の特徴\n\nすすき開花 × summer：−0.58、すすき開花 × autumn：−0.63\n夏〜秋が高温な年ほど すすきは早く咲く\n単純な「秋イベント」ではないことを示唆"
  },
  {
    "objectID": "reports/生物季節観測相関.html#季節平均気温どうし右下",
    "href": "reports/生物季節観測相関.html#季節平均気温どうし右下",
    "title": "生物季節観測データの相互相関解析",
    "section": "季節平均気温どうし（右下）",
    "text": "季節平均気温どうし（右下）\n\nspring–summer：0.44、summer–autumn：0.58、autumn–winter：0.37\n季節間には連続性はあるが、完全ではない\n各季節を独立変数として扱う妥当性が確認できる"
  },
  {
    "objectID": "reports/生物季節観測相関.html#今後の方針",
    "href": "reports/生物季節観測相関.html#今後の方針",
    "title": "生物季節観測データの相互相関解析",
    "section": "今後の方針",
    "text": "今後の方針\n\nSpearman相関なので\n\n単調関係は捉えているが因果ではないことに注意が必要\n長期トレンド（温暖化）を含む可能性がある\n長期トレンド除去後の相関を検討する必要がある\n\nかえで や いちょう が「何を感じているのか」を突き止めたい"
  }
]